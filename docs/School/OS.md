# 操作系统

## 第一章 操作系统导论

操作系统的定义：一组控制与管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合

操作系统的基本特性：并发(多个程序产生)，共享(互斥共享/同时共享，交替)，虚拟，异步性

操作系统的主要功能：

- 处理机管理：进程控制，同步，通信
- 存储器管理：内存分配、内存保护，地址映射
- 设备管理：缓冲管理，设备分配，设备处理，虚拟设备
- 文件管理：存储空间管理，目录管理，文件的读/写管理和保护
- 用户接口：命令接口，程序接口，图形接口

## 第二章 进程管理

### 2.1 进程的基本概念

顺序执行特征：

- 顺序性：下一操作要等待前一操作结束
- 封闭性：执行独占资源，不受外界影响
- 可再现性：重复执行将获得相同结果

前趋图：描述进程之间执行的前后关系，前趋图不存在循环

S1: a∶ = x+2，S2: b∶ = y+4，S3: c∶ = a+b，S4: d∶ = c+b

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719373909_0.png" alt="image-20240626115148213" style="zoom:50%;" />

程序并发执行时的特征：

- 间断性
- 失去封闭性
- 不可再现性

进程的结构：

- 进程由程序、数据和进程控制块 PCB 三部分组成
- 程序：描述进程要完成的功能，代码段
- 数据：进程执行时所需要的数据区，数据段
- 进程控制块 PCB：一种数据结构，用于标识进程的存在，记录进程执行过程各个时刻的状态特征

进程的特征：

- 动态性：创建-执行-消亡
- 并发性：多个进程共存在内存，同时执行
- 独立性：资源独立，互补干扰
- 异步性：速度不可预知

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

进程 vs 程序：

- 进程是动态的执行实体，程序是静态的数据和指令的集合
- 一个程序也有多个进程
- 进程用于并发执行和接收调度，程序用于存储数据和接收系统启动
- 进程执行需要 CPU，程序存储需要存储器
- 进程是有生命周期的，程序是永存的

进程的分类：

- 系统进程：管态(系统态，核心态)下执行，可以执行一切指令
- 用户进程：用户态下执行，不能直接做 IO，只能执行特定指令

进程的三种基本状态：

- 就绪态：获得 CPU 以外的所有资源
- 执行态：获取 CPU，执行过程
- 阻塞态：发生某种事件暂时无法进行，放弃 CPU 处于暂停状态，如请求 I/O，请求缓冲空间，处于阻塞队列

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719728327_0.png" alt="image-20240630141845449" style="zoom: 33%;" />

挂起状态：一种静止状态，不能马上投入运行，静止就绪和静止阻塞

原因：终端用户的请求：gdb 调试，父进程请求：子进程同步，存储系统需要：检查资源的使用情况

系统睡眠就是一种操作系统的整体挂起

创建态：用于进程初始化，拥有 PCB，但未获得资源，如程序数据未读入内存

终止态：进程结束，资源释放回收，释放 CPU，释放所有资源



PCB 作用：

- 进程存在的唯一标志
- 记录进程的外部特征
- 描述进程变化的过程
- 记录进程和其他进程的联系
- OS 通过 PCB 控制和管理进程，进入执行态，通信，挂起

PCB 信息：

- 进程标识符
- 处理机状态：各种寄存器信息
- 进程调度信息：进程调度和进程对换有关的信息
- 进程控制信息：进程资源信息

进程控制块的组织方式

链接方式：

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719728841_0.png" alt="image-20240630142721242" style="zoom:50%;" />

索引方式：

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719728870_0.png" alt="image-20240630142750412" style="zoom:50%;" />

原语：一系列操作的原子操作，事务

进程控制：

- 进程创建(用户登录，作业调度，应用请求创建子进程)：申请空白 PCB -> 分配资源 -> 初始化 PCB -> 将新进程插入就绪队列

- 进程终止(正常结束 halt，异常结束：越界，超时，父进程终止)：从 PCB 集合检索进程状态 PCB -> 处于执行状态，终止执行，置调度标志为真，在进程被终止后重新调度 -> 终止子孙进程 -> 回收资源，归还给其他父进程/系统 -> 删除 PCB，移出所在队列/链表。 
- 进程阻塞(主动行为)：停止执行 -> 修改状态为阻塞 -> 将 PCB 插入阻塞队列 -> 重新调度，处理器分配给另一就绪进程 -> CPU 环境切换，保存被阻塞进程的 CPU 状态到 PCB 中，将新进程 PCB 的 CPU 状态设置 CPU 新环境
- 进程唤醒：把阻塞进程从阻塞队列中移出 -> 将 PCB 的状态改为就绪 -> PCB 插入就绪队列
- 进程挂起：检查状态 活动就绪变为静止就绪，活动阻塞改为静止阻塞 -> PCB 复制到指定的内存区域 -> 数据复制到外存，释放内存 -> 若挂起的进程正在执行，重新调度
- 进程激活：进程从外存调入内存 -> 检查状态 静止就绪变为活动就绪，静止阻塞改为活动阻塞 -> 若是进入就绪队列，重新调度

进程同步：是使并发进行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性

信号量机制：

- 整型信号量：使用一个代表资源数目的整型变量，wait(S)和 signal(S)，PV 操作，-1/+1，缺点：忙等

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719736963_0.png" alt="image-20240630164242740" style="zoom: 50%;" />

- 记录型信号量：不存在忙等，让权等待，增加一个进程链表，链接所有等待进程，semaphore = value(资源可用数量), L:(等待进程队列)， wait -> block, signal -> wakeup

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719736988_0.png" alt="image-20240630164308015" style="zoom:50%;" />

- AND 型信号量：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。对若干个临界资源的分配，采取原子操作方式：要么全部分配到进程，要么一个也不分配。
- 记录型信号量：请求 1 种资源，数量 1 个
- AND 型信号量：请求 n 种资源，每种数量 1 个
- 信号量集：请求 n 种资源，每种数量 n 个
- 信号量 S，需求值 d，下限值 t，操作 Swait 和 Ssignal

进程同步：

- 信号量实现进程互斥：semphore mutex = 1, P1(){P(mutex) ~ V(mutex)}, P2(){P(mutex) ~ V(mutex)}
- 信号量实现进程同步：前 V 后 P

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719737256_0.png" alt="image-20240630164736431" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719737380_0.png" alt="image-20240630164940525" style="zoom: 33%;" />

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719737403_0.png" alt="image-20240630165003185" style="zoom:33%;" />

生产者-消费者问题：

- 具有 n 个缓冲区公用缓冲池
- 互斥信号量 mutex 实现诸进程对缓冲池的互斥使用
- 信号量 empty 表示缓冲池中空缓冲区数量。
- 信号量 full 表示缓冲池中满缓冲区的数量。
- mutex 为公用信号量，full 与 empty 与私用信号量
- 缓冲池未满，生产者可以将消息送入缓冲池
- 缓冲池未空，消费者可以从缓冲池中取走消息

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719737671_0.png" alt="image-20240630165431666" style="zoom:33%;" />

- 公有信号量：在单个程序成对出现
- 私有信号量：在不同程序中出现
- 先私后公

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719737958_0.png" alt="image-20240630165918522" style="zoom:33%;" />

​    桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自已需要的水果时，儿子或女儿可以从盘子中取出水果。用 PV 操作实现上述过程。

同步关系：
1. 父亲将苹果放入盘子后，女儿才能取苹果
1. 母亲将橘子放入盘子后，儿子才能取橘子
1. 只有盘子为空时，父亲和母亲才能放入水果

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719747647_0.png" alt="image-20240630194045601" style="zoom: 33%;" />

仓库管理有入货和出货两个操作。仓库内共有 50 个空位，最多存放 50 件货物。另外有一张登记表，无论入货或出货都需要在上面做登记。

- 入货流程是：仓库登记，存放货物
- 出货流程是：仓库登记，取出货物

```
Semaphore tmutex = 1, shelf = 50, item = 0;

In(){
	wait(shelf);	// 等待有空位
	wait(tmutex);
	登记;
	存放货物;
	signal(tmutex);
	signal(item);
}

Out(){
	wait(item);
	wait(tmutex);
	登记;
	取出货物;
	signal(tmutex);
	signal(shelf);
}
```

​    假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719748343_0.png" alt="image-20240630195223254" style="zoom:33%;" />

读者-写者问题

- 一个数据文件可被多个进程共享
- 允许多个进程同时读，禁止多个进程同时写
- 当一个进程写的时候，其他所有读进程都要停止
- 当进程读的时候，不允许写进程的发生
- 读写是互斥的

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719748889_0.png" alt="image-20240630200128707" style="zoom: 33%;" />

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719749058_0.png" alt="image-20240630200417891" style="zoom:33%;" />

哲学家进餐问题：

- 五个哲学家围坐一张圆桌
- 每两个哲学家之间有一根筷子
- 每个哲学家只能拿相邻的两根筷子，每次只能拿一根
- 每个哲学家只有拿到两根筷子才能进食

-----

进程通信：

高级进程通信类型

- 共享存储器，Share Memory，信息无格式
- 消息传递，Message Passing，信息有格式
  - 直接通信：Send(P1, msg1), Receive(P1, msg1)
  - 间接通信：信箱， Send(mailbox, message)， Receive(mailbox, message);
- 管道通信，Pipe，以文件方式



线程的特点：

- 轻型实体。 
- 独立调度和分派的基本单位。 
- 可并发执行。 
- 共享进程资源

## 第三章

处理机调度：

- 高级调度：根据调度算法和计算机状态，从 **外存中选择一个或多个作业调入内存**，每个作业调入一次，调出一次，调入创建 PCB
- 低级调度：进程调度，决定哪个进程获得 CPU，保存现场，调度新进程，
  - 三个基本机制：排队器，分派器，上下文切换机制
  - 非抢占式：正在运行的进程运行完毕或发生阻塞，才把 CPU 分配给其他进程
  - 抢占式：允许暂停当前执行的进程，重新分配 CPU(优先权原则，短作业优先，时间片)
- 中级调度：为了使得暂时不能运行的进程不占用宝贵的内存资源，将它们调至外存，挂起和唤醒，提高内存利用率和系统吞吐量

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719756041_0.png" alt="image-20240630220041383" style="zoom:33%;" />

高级、中级和低级调度：

- 高级调度：以作业为调度对象
  - 从外存到内存
  - 进程创建操作
- 中级调度：以进程为调度对象
  - 外存与内存互换
  - 挂起与唤醒操作
- 低级调度：以进程为调度
  - 对象一直在内存中
  - 分配 CPU 执行程序

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719758768_0.png" alt="image-20240630224607972" style="zoom: 50%;" />

选择调度算法的准则：

- 面向用户的准则：周转时间短(作业进入到完成的时间)，响应时间快，截止时间的保证，优先权准则
- 面向系统的准则：系统吞吐量高，处理机利用率好，各类资源的平衡利用

固定属性：

- 到达时间：进入系统的时间
- 开始时间：首次使用 CPU 的时间
- 服务时间：需要使用 CPU 的时间，又叫运行时间
- 完成时间：退出系统的时间
- **周转时间：完成时间-到达时间**，包含服务时间和等待时间，若等待时间为 0 即没有等待
- 平均周转时间：周转时间 / 服务时间
- **带权周转时间 = 周转时间 / 运行时间** 

调度算法：

先来先服务调度 FCFS(非抢占式)：

- 作业调度：按时间先后，选择最先来的作业
- 进程调度：从就绪队列中，选择最先进入的进程，队首进程

短作业优先调度 SJF(非抢占式)：选择时间最短的，有利于短作业，导致长作业长时间不被调度，不能保证实时性

高优先权优先调度：

- 静态优先：创建进程时已经确定并在运行时不变
- 动态优先：随进程的推进或等待时间增加而改变
- 优先权 = 等待时间+要求服务时间/要求服务时间 = 响应时间/要求服务时间

高响应比优先调度算法的优点：

- 对于等待时间相同的时候，服务时间愈短则优先权愈高，算法有利于短作业
- 对于服务时间相同的时候，等待时间愈长其优先权愈高，算法实现的是先来先服务。
- 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高保证能获得处理机。  

缺点：每次调度前都要计算优先权，增加系统开销



基于时间片的轮转调度算法：

- 将所有就绪进程按先来先服务排成队列
- 把 CPU 分配给队首进程，进程只执行一个时间片
- 时间片用完，OS 通过计时器发出时钟中断，停止进程
- 将已使用时间片的进程送往就绪队列的末尾
- 分配处理机给就绪队列中下一进程



多级反馈队列调度算法调度规则：

- 每个新进程首先进入第一个队列，遵循 FCFS
- 在当前队列的时间片内，进程若能完成，退出进程
- 若未完成，降级到第二个队列，同样遵循 FCFS
- 依次类推，若在第二个队列的时间片内仍未完成，再降级到第三个队列……
- 高级队列未空，低级队列不能调度

实时调度：

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719760872_0.png" alt="image-20240630232112016" style="zoom:50%;" />

常用的几种实时调度算法

- 最早截止时间优先(EDF, Earliest Deadline First)算法 
  - 根据任务的开始截止时间确定任务优先级
  - 开始截止时间越早，优先级越高
- 最低松弛度优先(LLF, Least Laxity First)算法
  - 根据任务紧急(或松弛)的程度确定任务的优先级。
  - 任务的紧急程度愈高，优先级就愈高
  - 临界状态发生抢占，松弛度为 0 发生抢占
  - **松弛度 = 完成截止时间 – 处理时间 – 当前时间**
  - 例如任务 A 的完成截止时间是第 400s，运行时间为 100s，当前时间是第 150s，则 A 的松弛度 = 400 – 100 – 150 = 150s
  - 注意：处理时间指剩余需要 CPU 时间，初始化等于运行时间



死锁：多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前进产生

死锁的原因：竞争资源，进程间推进顺序非法



产生死锁的必要条件互斥条件：

- 请求资源为临界资源，将引发进程阻塞
- 请求和保持条件：持有旧资源，同时申请新资源
- 不剥夺条件：已获得资源在使用完之前，不被外力剥夺
- 环路等待条件：互相等待资源



处理死锁的基本方法

- 预防死锁：设置限制条件，破坏产生死锁的一个或多个必要条件
- 避免死锁：在资源动态分配过程中，加入检查，防止系统进入不安全状态
- 检测死锁：建立检测机构检测死锁的发生和原因，确定相关的进程和资源
- 解除死锁：剥夺资源或撤销进程，从而解除死锁
- 检测死锁和解除死锁是一对合作关系



## 文件管理

有结构文件：文件由若干个记录组成，例如表格

无结构文件：字符流，特例，只包含一个无标识记录的文件

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720000279_0.png" alt="image-20240703175119023" style="zoom:50%;" />

文件属性：类型，长度，物理位置，建立时间

文件类型：

- 系统文件，用户文件，库文件
- 数据形式：源文件，目标文件，可执行文件
- 存储形式：只执行，只读，可读/写

文件系统：负责管理管理外存上的文件，为用户提供文件的存取、共享、保护等功能。



文件逻辑结构：即文件组织，用户可以直接处理的数据及其结构，分为有结构文件和无结构文件

文件物理结构：文件在外存上的存储组织形式



有结构文件：定长记录和变长记录，顺序文件，索引文件，索引顺序文件

UNIX 系统，所有文件都是流式文件



顺序文件：记录逻辑上一个一个顺序排列，记录可用定长/变长，记录在物理上可用顺序存储/链式存储

- 串结构：记录之间的顺序与关键字无关
- 顺序结构：记录按关键词排序

优点：适用于批量存取，连续大批读/写记录，磁带机

缺点：不方便查找与修改，含有 n 个记录，平均每次查找需要 n/2 次，可变长记录更大，增加新记录或删除旧记录麻烦，配置日志文件或事务文件



索引文件：

- 为可变长记录文件建立一张索引表
- 索引表按关键字排序
- 索引表本身是定长记录的顺序文件
- 优点：方便增删改
- 缺点：索引表需要额外存储

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720003699_0.png" alt="image-20240703184819066" style="zoom: 50%;" />

索引顺序文件：

- 将记录分为若干组
- 每组的第一个记录作为索引项，建立索引表
- 索引表按记录键排序，是一个定长记录文件
- 索引表长度较短，节省存储空间

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720003777_0.png" alt="image-20240703184937338" style="zoom:50%;" />

三种文件的查找记录：100W 条记录

- 顺序文件：50W 次
- 索引文件：按索引方法查找，额外 100W 个索引空间，50W 次
- 索引顺序文件：二级索引，100W -> 10000 个组 -> 100 个群，50 + 50 + 50 = 150 次 



文件目录：

文件控制块 FCB：

- 基本信息类：文件名，物理位置，逻辑结构，物理结构
- 存取控制信息类
- 使用信息类



单级目录：所有文件使用一张目录表

二级目录：按用户划分，提交速度，支持重名，方便共享

多级目录：构造目录树

- 当前目录：为每个进程设置，简化路径
- 增减目录：建立新分支
- 删除目录：非空目录递归，从底向上删除
- 查询目录：树遍历，Hash 方法





FCB 过大，单个盘的 FCB 数量较少，导致查找文件需要访问多个盘块，

索引节点，将文件描述信息存放在索引节点中，构建目录表，文件名和索引节点指针，

例如：FCB = 64B 盘块为 1KB，16 个 FCB，一个目录包含 640 个文件，需要 40 个盘块，查找需要 20 个盘块

目录项为 16 个字节，14B 用于文件名，2B 用于指针，1KB 存储 64 个目录项，只需访问 10 个盘块，平均查找 5 个盘块

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720004675_0.png" alt="image-20240703190435348" style="zoom:33%;" />

磁盘索引结点：

- 文件主标识符 
- 类型、存取权限 
- 物理地址、长度 连接计数
- 存取时间

内存索引结点：将磁盘索引结点拷贝到内存

- 内存索引结点编号
- 状态：结点是否上锁或被修改访问
- 计数：有新进程访问则计数加 1， 访问完再减 1
- 文件所属文件系统的逻辑设备号
- 链接指针：设置有分别指向空闲链表和散列队列的指针



外存分配方式：

连续分配：为文件分配一组相邻接的盘块

优点：顺序访问/直接访问容易，访问速度快，

缺点：要求由连续的存储空间，产生碎片，存储时需要事先知道文件的长度，不方便文件拓展

文件目录记录：文件名 起始块号 长度 

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720005274_0.png" alt="image-20240703191433894" style="zoom: 50%;" />

链接分配：将同一文件的盘块采用指针链接到一起

隐式链接：链接指针放在盘块内

优点：不存在碎片，不需要连续空间，不需要事先知道文件长度

缺点：

- 适合顺序访问，不适合随机访问
- 可靠性差，指针出错会数据丢失
- 指针占用数据区

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720005309_0.png" alt="image-20240703191508775" style="zoom:50%;" />

显示链接：盘块的指针存放在链接表中，又称文件分配表，FAT 表，结尾-1

缺点：不支持高速直接存储；FAT 占用内存空间

优点：无外部碎片，方便拓展，转换不需要磁盘操作

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720005511_0.png" alt="image-20240703191830809" style="zoom:50%;" />

索引分配：为每个文件分配索引表，将记录存在索引表，一级索引：每个文件只有一张索引表

缺点：额外空间，文件多会使得索引库过大，导致盘块更多，速度变慢  -> 多级索引

计算最大文件长度：

一级索引：磁盘块 1KB，索引表项 4B，则一个磁盘块最多 256 个索引项，

一个文件 256\*256KB = 64MB，由 256\*256 个块，对应 256\*256 个索引项，需要 256 个索引块，

二级索引：文件最大长度 256\*256*1KB = 64MB

访问 1026 号逻辑块，1026/256 = 4，1026%256 = 2。一级索引 4 对应的二级索引，2 号表即为物理块，3 次磁盘 IO

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720005744_0.png" alt="image-20240703192224219" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720006461_0.png" alt="image-20240703193421354" style="zoom:50%;" />

在一操作系统中采用索引分配方式为文件分配外存，假定盘块大小为 4KB，每个盘块号占用 4 个字节，请分别计算使用一级索引、二级索引、三级索引支持的文件最大长度。

4KB/4B = 1024 = 2^10^ 个索引项

一级索引：2^10^ * 4KB = 2^12^ KB = 4MB

二级索引：2^10^ \* 2^10^ \* 4 KB = 2^22^ KB = 4GB

三级索引：2^10^ \* 2^10^ \* 2^10^ \* 4 KB = 2^32^ KB = 4TB



文件存储空间的管理：对空间进行分配和回收

空闲表：
