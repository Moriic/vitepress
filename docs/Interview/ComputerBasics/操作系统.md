# 操作系统

## 功能

1. **进程和线程的管理**：进程的创建、撤销、阻塞、唤醒，进程间的通信等。
2. **存储管理**：内存的分配和管理、外存(磁盘等)的分配和管理等。
3. **文件管理**：文件的读、写、创建及删除等。
4. **设备管理**：完成设备(输入输出设备和外部存储设备等)的请求或释放，以及设备启动等功能。
5. **网络管理**：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。
6. **安全管理**：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。

## 用户态和内核态

- **用户态(User Mode)**：用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限，当应用程序需要执行某些特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。
- **内核态(Kernel Mode)**：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1711511059_0.png" alt="usermode-and-kernelmode" style="zoom: 67%;" />

### 为什么需要两个态

- 同时具有用户态和内核态主要是为了保证计算机系统的安全性、稳定性和性能。

- 如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。

### 切换方式

1. **系统调用(Trap)**：用户态进程主动切换到内核态，为了使用内核态才能做的事情，如读取磁盘资源。系统调用的机制其核心还是使用了中断
2. **中断(Interrupt)**：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，CPU 会去执行要处理的程序，如果向前执行的指令是用户态下的程序，会切换到内核态，结束后切换会用户态
3. **异常(Exception)**：当 CPU 在执行运行在用户态的程序时，发生了异常，则会切换到处理该异常的内核态中，如缺页异常

## 系统调用

- 调用操作系统提供的内核态级别的功能(文件管理，进程控制，内存管理)
- 普通的库函数调用运行于用户态

### 过程

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1711512021_0.png" alt="system-call-procedure" style="zoom: 67%;" />

1. 用户态程序发起系统调用，涉及内核态的指令，权限不足会中断执行 Trap
2. 发生中断后，CPU 程序会中断，跳转到中断处理程序，内核程序开始运行，处理系统调用
3. 系统调用处理完后，主动触发 Trap，再次发生中断，切换到用户态

## 进程和线程

- 进程(Process)：计算机正在运行的一个程序实例，如打开的微信
- 线程(Thread)：轻量级进程，多个线程可以在一个进程中同时执行，并且共享进程的资源如内存空间，文件句柄，网路连接等，如微信中有个线程专门拉取消息

### 区别

一个进程中可以有多个线程，多个线程共享进程的 **堆** 和 **方法区**(JDK1.8 之后的元空间)资源，但是每个线程有自己的 **程序计数器**、**虚拟机栈** 和 **本地方法栈**。

- **线程是进程划分成的更小的运行单位**，一个进程在其执行过程可以产生多个线程
- 线程和进程 **最大的不同在于各进程是独立的，而线程不一定，可能会相互影响**
- **线程执行开销小**，当不利于资源管理和保护

### 为什么需要线程

- **进程切换是个开销很大的操作，线程切换成本较低**
- 线程更轻量，一个进程可以创建多个线程
- 多个线程可以 **并发处理多个任务，** 有效利用了多处理器和多核计算机，而进程只能干一件事，**遇到 IO 等阻塞就会挂起**
- 同一进程内的 **线程共享内存和文件**，因此他们之间通信 **无需调用内核**

### 同步方式

1. 互斥锁(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。Java 的 `synchronized` 和 `Lock`
2. 读写锁(Read-Write Lock)：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作
3. 信号量(Semaphore)：允许多个线程同时读取共享资源，但需要控制同一时刻访问此资源的最大线程数量
4. 屏障(Barrier)：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行，当一个线程到达屏障时，他会停止执行并等待其他线程到达屏障，直到所有线程到达屏障后，它们才会一起继续执行。如 Java 中的 `CyclicBarrier`
5. 事件(Event)：Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

### PCB

- PCB(Process Control Block)：进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB
- 当操作系统创建一个新进程时，会为进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块 PCB，当进程执行时，PCB 的信息会不断变化，存储系统会根据这些信息来管理和调度进程
- PCB 包含以下内容：
  - 进程的描述信息，包括进程的名称、标识符等等；
  - 进程的调度信息，包括进程阻塞原因、进程状态(就绪、运行、阻塞等)、进程优先级(标识进程的重要程度)等等；
  - 进程对资源的需求情况，包括 CPU 时间、内存空间、I/O 设备等等。
  - 进程打开的文件信息，包括文件描述符、文件类型、打开模式等等。
  - 处理机的状态信息(由处理机的各种寄存器中的内容组成的)，包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针。
  - ……


### 进程的状态

- **创建状态(new)**：进程正在被创建，尚未到就绪状态
- **就绪状态(ready)**：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行
- **运行状态(running)**：进程正在处理器上运行
- **阻塞状态(waiting)**：等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成，即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)**：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1711546709_0.png" alt="state-transition-of-process" style="zoom: 67%;" />

### 进程间的通信方式

> [《进程间通信 IPC (InterProcess Communication)》](https://www.jianshu.com/p/c1015f5ffa74) 

1. **管道/匿名管道(Pipes)**：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
2. **有名管道(Named Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 **先进先出(First In First Out)** 。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. **信号(Signal)**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
4. **消息队列(Message Queuing)**：消息队列是消息的链表, 具有特定的格式, 存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道(无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统)不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询, 消息不一定要以先进先出的次序读取, 也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。**
5. **信号量(Semaphores)**：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. **共享内存(Shared memory)**：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

### 进程的调度算法

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1711547075_0.png" alt="scheduling-algorithms-of-process" style="zoom:67%;" />

- **先到先服务调度算法(FCFS，First Come, First Served)** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **短作业优先的调度算法(SJF，Shortest Job First)**: 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **时间片轮转调度算法(RR，Round-Robin)**: 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法(MFQ，Multi-level Feedback Queue)**：前面介绍的几种进程调度的算法都有一定的局限性。如 **短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业(进程)迅速完成。，因而它是目前 **被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。
- **优先级调度算法(Priority)**：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

### 僵尸进程和孤儿进程

- **僵尸进程**：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。

- **孤儿进程**：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源

## 死锁

死锁（Deadlock）描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。

### 产生死锁的四个条件

1. **互斥**：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
2. **占有并等待**：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
3. **非抢占**：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
4. **循环等待**：有一组等待进程 `{P0, P1,..., Pn}`， `P0` 等待的资源被 `P1` 占有，`P1` 等待的资源被 `P2` 占有，……，`Pn-1` 等待的资源被 `Pn` 占有，`Pn` 等待的资源被 `P0` 占有。

### 模拟死锁代码

```java
public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}
```

### 解决死锁的方法

- **预防**：采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间上都不满足。
- **避免**：系统在分配资源时，根据资源的使用情况 **提前做出预测**，从而 **避免死锁的发生**
- **检测**：系统设有 **专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。
- **解除**：与检测相配套的一种措施，用于 **将进程从死锁状态下解脱出来**。

### 预防死锁

1. 静态分配策略(第二个条件)：一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。**进程要么占有所有的资源然后开始执行，要么不占有资源**，不会出现占有一些资源等待一些资源的情况。
2. 层次分配策略(第四个条件)：所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略

### 避免死锁

​    我们将系统的状态分为 **安全状态** 和 **不安全状态** ，每当在为申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。


	
