# 计算机网络

## 网络分层模型

### OSI 七层模型

- 应用层：为计算机用户提供服务
- 表示层：数据处理(编解码、加密解密、压缩解压缩)
- 会话层：管理(建立、维护、重连)应用程序之间的会话
- 传输层：为两台主机进程之间的通信提供通用的数据传输服务
- 网络层：路由和寻址(决定数据在网络的游走路径)
- 数据链路层：帧编码和误差纠正控制
- 物理层：透明地传送比特流传输

<img src="https://cdn.jsdelivr.net/gh/Moriic/picture@main/img/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png" alt="osi七层模型2" style="zoom: 33%;" />

### TCP/IP 四层模型

- 应用层：提供两个终端设备上的应用程序之间的信息交换的服务，定义了信息交换的格式，消息交给下一次传输层来传输。应用层交互的数据单元称为 **报文**。
- 传输层：向两台终端设备之间的通信提供通用的数据传输服务。
- 网络层：负责为分组交换网的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。
- 网络接口层：数据链路层 + 物理层
  - 数据链路层：将网络层的 IP 数据报组装成帧，两个相邻节点间的链路上传送帧，每一帧包括数据和必要的控制信息(同步信息，地址信息，差错控制)
  - 物理层：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。


<img src="https://cdn.jsdelivr.net/gh/Moriic/picture@main/img/network-protocol-overview.png" alt="network-protocol-overview" style="zoom:50%;" />

#### 应用层



<img src="https://cdn.jsdelivr.net/gh/Moriic/picture@main/img/application-layer-protocol.png" alt="application-layer-protocol" style="zoom:50%;" />

- HTTP：TCP，用于传输超文本和多媒体内容的协议，为了 Web 浏览器之间的通信设计的

- SMTP：TCP，用于发送电子邮件的协议，只发送，不是接收，从邮件服务器接收邮件需要使用 POP3 或 IMAP 协议

- POP3/IMAP：TCP，负责邮件的接收

- FTP：TCP，传输文件，可屏蔽操作系统和文件存储方式。不加密，不安全，使用 SFTP

- Telnet：远程登陆协议，TCP，所有数据明文，使用 SSH

- SSH：TCP，通过加密和认证机制实现安全的访问和文件传输等业务

- RTP：实时传输协议，UDP

- DNS：域名管理系统，UDP

#### 传输层

<img src="https://cdn.jsdelivr.net/gh/Moriic/picture@main/img/image-20240313204947493.png" alt="image-20240313204947493" style="zoom:33%;" />

- TCP：面向连接，可靠的数据传输服务

- UDP：无连接，尽最大努力的数据传输服务

#### 网络层

<img src="https://cdn.jsdelivr.net/gh/Moriic/picture@main/img/nerwork-layer-protocol-FaRmSAcs.png" alt="nerwork-layer-protocol-FaRmSAcs" style="zoom:50%;" />

- IP：网络协议，定义数据包的格式，对数据包进行路由和寻址，以便可以跨网络传输并到达正确的目的地。
- ARP：地址解析协议，解决网络层和链路层地址之间的转换问题，IP 转 MAC 地址
- ICMP：互联网控制报文协议，用于传输网络状态和错误消息的协议，用于网络诊断和故障排除，如 Ping
- NAT：网络地址转换协议，应用于内部网到外部网的地址转换过程。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。
- OSPF：开放式最短路径优先，内部网关协议，动态路由协议，基于链路状态算法，考虑链路的带宽，延迟选择最佳路径
- RIP：路由信息协议，内部网关协议，动态路由协议，基于距离向量算法，选择跳数最短的路径
- BGP：边界网关协议，路由选择域之间交换网络层可达性信息的路由选择协议

#### 网络接口层

<img src="https://cdn.jsdelivr.net/gh/Moriic/picture@main/img/network-interface-layer-protocol.png" alt="network-interface-layer-protocol" style="zoom:50%;" />

#### 分层原因

- 各层之间相互独立，不需要关心其它层的实现
- 提高整体灵活性，每一层使用最适合的技术，高内聚低耦合
- 大问题化小，功能分解

## HTTP

### 输入 URL 到页面展示的过程

| 过程                                                         | 协议                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 浏览器查找域名的 IP 地址(DNS 查找过程：浏览器缓存，路由器缓存，DNS 缓存) | DNS：获取域名对应的 IP                                       |
| 浏览器向 Web 服务器发送一个 HTTP(TCP) 请求(cookies 随请求发送) | TCP：与服务器建立 TCP 连接                                   |
| 服务器处理请求(处理请求参数，cookies，生成 HTML 响应)        | IP：建立 TCP 协议时，需要发送数据，发送数据在网络层使用 IP 协议 |
| 服务器返回一个 HTML 响应                                     | OSPF：IP 数据包在路由器之间选择最佳路径                      |
| 浏览器开始显示 HTML                                          | ARP：IP 转 MAC 地址                                          |
|                                                              | HTTP：TCP 建立完成，使用 HTTP 访问网页                       |

1. 在浏览器中输入指定网页的 URL。
2. 浏览器通过 DNS 协议，获取域名对应的 IP 地址。
3. 浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。
4. 浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。
5. 服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。
6. 浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。
7. 浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。

### URL

协议 + 域名 + 端口 + 资源路径 + 参数

### HTTP 状态码

| 状态码 | 类别                           | 原因                       |
| ------ | ------------------------------ | -------------------------- |
| 1XX    | Informational(信息性状态码)    | 接收的请求正在处理         |
| 2XX    | Success(成功状态码)            | 请求处理完毕               |
| 3XX    | Redirection(重定向状态码)      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error(客户端错误状态码) | 服务器无法处理请求         |
| 5XX    | Server Error(服务端错误状态码) | 服务器处理请求错误         |

- **200 OK**：请求被成功处理。比如我们发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。

- **201 Created**：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。

- **202 Accepted**：服务端已经接收到了请求，但是还未处理。

- **204 No Content**：服务端已经成功处理了请求，但是没有返回任何内容。



- **301 Moved Permanently**：资源被永久重定向了。比如你的网站的网址更换了。
- **302 Found**：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。



- **400 Bad Request**：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。
- **401 Unauthorized**：未认证却请求需要认证之后才能访问的资源。
- **403 Forbidden**：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。
- **404 Not Found**：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。
- **409 Conflict**：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。



- **500 Internal Server Error**：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。

- **502 Bad Gateway**：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。

### HTTP vs HTTPS

- 端口号：HTTP 默认 80，HTTPS 默认 443
- URL 前缀：http:// 和 https://
- 安全性和资源消耗：HTTP 协议运行在 TCP 上，传输明文，客户端和服务端都无法验证对方身份。HTTPS 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 上，传输内容经过加密，使用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密，HTTP 没有 HTTPS 安全，HTTPS 资源耗费高
- SEO：搜索引擎青睐使用 HTTPS 协议的网站



非对称加密：一个公钥，一个私钥，通信时，私钥由解密者保存，公钥由任何一个想与解密者通信的发送者(加密者)所知，公钥只能加锁，私钥来解锁

对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。

非对称加密耗费高，只需一次对对称加密的密钥进行加密：

使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性

攻击者伪装服务端 S 发给客户端公钥 C，获取客户端的信息：

为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的电子签名

当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。

数字签名：

数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 **靠数字签名技术** 。

数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：



### HTTP/1.0 vs HTTP/1.1

- 连接方式：1.0 短连接，1.1 支持长连接，一次 TCP 连接后不会关闭
- 状态响应码：加入大量响应码
- 缓存机制：1.0 使用 Header 的 If-Modified-Since, Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 
- 带宽：1.1 引入 range 头域，支持只请求资源的某个部分
- Host 头处理：允许同一 ip 地址托管多个域名，支持虚拟主机的功能

### HTTP/1.1 vs HTTP/2.0

- 多路复用：2.0 同一连接可以传输多个请求和响应，互补干扰，1.0 为串行
- 二进制帧：2.0 使用二进制帧进行数据传输，1.0 使用文本格式的报文
- 头部压缩：1.0 支持 Body 压缩，Header 不支持压缩，2.0 都支持
- 服务器推送：2.0 客户端请求一个资源时，其他相关资源一并推送给客户端

### HTTP 时不保存状态协议，如何保存用户状态

HTTP 时无状态协议，使用 Session 机制，通过服务器记录用户的状态，内存/数据库，在 Cookie 中附加一个 Session ID

Cookie 被禁用：把 Session ID 附加在 URL 后面

### URI vs URL

URI：统一资源标志符，唯一标识一个资源

URL：统一资源定位符，具体的 URI，不仅标识，还指明如何 locate 这个资源

### GET vs POST

- 语义：GET 通常获取和查询资源，POST 通常创建和修改资源
- 幂等：GET 时幂等的，多次重复执行不改变资源的状态，POST 不幂等，每次执行可能产生不同结果
- 格式：GET 请求参数一般放 URL，长度受限；POST 请求体 body 里面，multipart/form-data、application/json
- 缓存：GET 可以被缓存，提高性能
- 安全性：HTTP 都不安全，明文，GET 参数放 URL 更不安全

## WebSocket

客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

应用场景：

- 视频弹幕
- 实时消息推送
- 实时游戏对战
- 多用户协同编辑
- 社交聊天

### WebSocket vs HTTP

- WebSocket 是双向实时通信协议，HTTP 是一种单向通信协议，服务器无法主动通知客户端
- WebSocket 使用 ws:// 或 wss:// 
- WebSocket 支持拓展，实现自定义的子协议，如支持压缩、加密
- WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。

### 工作流程

1. 客户端发送一个 HTTP 请求，请求头中包含 `Upgrade: websocket` 和 `Sec-WebSocket-Key` 等字段，表示要求升级协议为 WebSocket；
2. 服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，`Connection: Upgrade` 和 `Sec-WebSocket-Accept: xxx` 等字段、表示成功升级到 WebSocket 协议。
3. 客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。
4. 客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。

另外，建立 WebSocket 连接之后，通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。

### SSE 和 WebSocket 区别

SSE 与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：

- SSE 是基于 HTTP 协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket 需单独服务器来处理协议。
- SSE 单向通信，只能由服务端向客户端单向通信；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。
- SSE 实现简单开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。
- SSE 默认支持断线重连；WebSocket 则需要自己实现。
- SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。

## PING

- **ICMP Echo Request（请求报文）信息**：序列号、TTL（Time to Live）值。

- **目标主机的域名或 IP 地址**：输出结果的第一行。

- **往返时间（RTT，Round-Trip Time）**：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。

- **统计结果（Statistics）**：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。

### 工作原理

PING 基于网络层的 ICMP，通过在网络上发送和接收 ICMP 报文实现。

ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型：

- 查询报文类型：向主机发送请求并期望得到响应
- 差错报文类型：向源主机发送错误信息，用于报告网络中的错误信息。

PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。

- PING 命令会向目标主机发送 ICMP Echo Request。
- 如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。

## DNS

域名管理系统：实现域名和 IP 的映射

- 浏览器 DNS 缓存，操作系统 DNS 缓存，路由器 DNS 缓存。
- **DNS 是应用层协议，它可以在 UDP 或 TCP 协议之上运行，端口为 53** 。
- 根 DNS 服务器，顶级域 DNS 服务器，权威 DNS 服务器，本地 DNS 服务器

### DNS 解析过程

**反复解析(迭代解析)**:

访问 netlab.csse.szu.edu.cn

本地域名服务器 -> 根域名服务器 edu.cn -> 本地 -> szu 域名服务器 szu.edu.cn -> 本地 -> csse 域名服务器 csse.szu.edu.cn -> 本地

<img src="https://cdn.jsdelivr.net/gh/cwcblog/picture@main/img/bbe9100019310cd36af63a773e2ca84a-1688272973280-51.png" alt="img" style="zoom:67%;" />

**递归解析**：

本地域名服务器 -> 根域名服务器 edu.cn -> szu 域名服务器 szu.edu.cn -> csse 域名服务器 csse.szu.edu.cn -> ... -> 本地

<img src="https://cdn.jsdelivr.net/gh/cwcblog/picture@main/img/7d54d2488f8e72894f05c870955851fe-1688272973280-53.png" alt="img" style="zoom:67%;" />

### DNS 劫持

​    DNS 劫持是一种网络攻击，它通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 DNS 重定向、DNS 欺骗或 DNS 污染。

## TCP 和 UDP

### 区别

1. 是否面向连接：UDP 在传送数据前不需要向建立连接，而 TCP 提供面向连接的服务，在传送数据之前需要向建立连接，结束后释放连接
2. 是否可靠传输：远程主机在收到 UDP 报文后，不需要给出确认，不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，在传输数据之前，会有三次握手建立连接，在数据传输时，有确认、窗口、重传、拥塞控制机制。TCP 传输能无差错、不丢失、不重复、并且按序到达。
3. 是否有状态：TCP 有状态，记录消息是否发送，接收等，TCP 维护复杂的连接状态表，UDP 无状态
4. 传输效率：UDP 更快
5. 传输形式：TCP 字节流，UDP 报文
6. 首部开销：TCP 20 ~ 60 字节，UDP 8 字节
7. 是否提供广播或多播服务：TCP 只支持点对点通信，UDP 支持一对一，多对多。

### 应用场景

UDP：即时通信，如语音、视频、直播 (DHCP：动态主机配置 ip 协议)

TCP：传输准确性高，文件传输，邮件，远程登陆

> https://cloud.tencent.com/developer/article/2157079

### TCP 三次握手

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1711264232_0.png" alt="tcp-shakes-hands-three-times" style="zoom:50%;" />

#### 三次握手流程

- 一次握手：client 发送带有 SYN(SEQ = x)标志的数据包给 Server，client 进入 SYN_SEND 状态，等待服务器的确认
- 二次握手：Server 发送带有 SYN+ACK(SEQ = y, ACK = x+1)标志的数据包给 Client，然后服务器进入 SYN_RECV 状态
- 三次握手：Client 发送带有 ACK(ACK = y+1)标志的数据包给 Client，客户端和服务器进入 ESTABLISHED 状态

#### 为什么需要三次握手？

确保双方的收发都是正常的

- **第一次握手**：Client 无法确认；Server 确认了对方发送正常，自己接收正常
- **第二次握手**：Client 确认了自己收发正常，Server 确认了对方发送正常，自己接收正常
- **第三次握手**：Client，Server 都确认双方收发正常

#### 两次握手/四次握手

- 两次握手不安全：Server 无法确认客户端的接收是否正常/服务端的发送是否正常
- 四次没必要

#### 三次握手可以携带数据吗？

​    第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。假设第一次可以携带数据，如果有人恶意攻击服务器，每次都在第一次握手中的 SYN 报文放入大量数据，重复发送大量 SYN 报文，此时服务器会花费大量内存空间来缓冲这些报文，服务器就更容易被攻击了

#### 三次握手失败，服务端会如何处理?

- 服务端没有收到 SYN，则什么都不做；
- 服务端回复了 SYN+ACK 后，长时间没有收到 ACK 响应，则超时后就会发送 RST 重置连接报文，释放资源

#### ISN 代表什么？意义何在？ISN 是固定不变的吗？ISN 为何要动态随机

​    `ISN` 全称是 `Initial Sequence Number`，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号。ISN 如果是固定的，攻击者很容易猜出后序的确认号，为了安全起见，避免被第三方猜到从而发送伪造的 `RST` 报文，因此 ISN 是动态生成的

### TCP 四次挥手

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1711277295_0.png" alt="tcp-waves-four-times" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1711278777_0.png" alt="f26c8846d0f8865aa758acbfd9d5d236" style="zoom:50%;" />

#### 四次挥手流程

- **第一次挥手**：Client 发送一个 FIN(SEQ = x)标志的数据包给 Server，用来关闭 Client 到服务器的数据传送。然后 Client 进入 FIN-WAIT-1 状态
- **第二次挥手**：Server 收到这个 FIN(SEQ = x)标志的数据包，发送 ACK(ACK = x+1)标志的数据包给 Client，然后 Server 进入 CLOSE-WAIT 状态，Client 进入 FIN-WAIT-2 状态
- **第三次挥手**：Server 发送一个 FIN(SEQ = y)标志的数据包给 Client，请求关闭连接，Server 进入 LAST-ACK 状态
- **第四次挥手**：Client 发送 ACK(ACK = y+1)标志的数据包给 Server，然后 Client 进入 TIME-WAIT 状态，Server 在收到 ACK(ACK = y+1)的数据包后进入 CLOSE 状态，如果 Client 等待 2MSL 后没收到回复，则 Server 正常关闭，Client 也可以关闭连接了

#### 为什么四次挥手

​    其实在TCP握手的时候，接收端将SYN包和ACK确认包合并到一个包中发送的，所以减少了一次包的发送。对于四次挥手，由于TCP是全双工通信，主动关闭方发送FIN请求不代表完全断开连接，只能表示**主动关闭方不再发送数据了**。而**接收方可能还要发送数据**，就不能立即关闭服务器端到客户端的数据通道，所以就不能将服务端的FIN包和对客户端的ACK包合并发送，**只能先确认ACK，等服务器无需发送数据时在发送FIN包**，所以四次挥手时需要四次数据包的交互

> 举个例子：A 和 B 打电话，通话即将结束后。
>
> 1. **第一次挥手**：A 说“我没啥要说的了”
> 2. **第二次挥手**：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话
> 3. **第三次挥手**：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”
> 4. **第四次挥手**：A 回答“知道了”，这样通话才算结束。

#### 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？

​    因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。

#### 如果第二次挥手时服务器的-ack-没有送达客户端-会怎样

​    客户端没有收到 ACK 确认，会重新发送 FIN 请求。

#### 为什么第四次挥手客户端需要等待 2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？

​    第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

​    客户端发送ACK后需要留出2MSL时间（ACK到达服务器器+服务器发送FIN重传包，一来一回）等待确认服务器端缺失收到了ACK包。也就是说客户端如果等待2MSL时间也没收到服务器端重传的FIN包，则就可以确认服务器已经收到客户端发送的ACK包

#### 一台主机上出现大量的TIME_WAIT是什么原因？应该如何处理？

​    TIME_WAIT是主动关闭方出现的，一台主机出现大量的TIME_WAIT证明这台主机上发起大量的主动关闭连接。常见于一些爬虫服务器。这时候我们应该调整TIME_WAIT的等待时间，或者开启套接字地址重用选项

#### 一台主机上出现大量的CLOSE_WAIT是什么原因？应该如何处理？

​    CLOSE_WAIT是被动关闭方收到FIN请求进行回复之后的状态，等待上层程序进一步处理，若出现大量CLOSE_WAIT，有可能是被动关闭方主机程序中忘了最后一步断开连接后调用close释放资源。这是一个 BUG.，只需要加上对应的 close 即可解决问题

### TCP 传输可靠性保障

#### TCP 如何保证传输可靠性？

