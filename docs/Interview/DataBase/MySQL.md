# MySQL

## MySQL 基础

### 关系型数据库

建立在关系模型上的数据库(一对一，一对多，多对多)

## MySQL 字段类型

- **数值类型**：整型(tinyint, smallint, mediumint, int, bigint)，浮点型(float, double)，定点型(decimal)
- **字符串类型**：char, varchar, tinytext, text, mediumtext, longtext, tinyblob, blob, mediumblob, longblob
- **日期类型**：year, time, date, datetime, timestamp

### char vs varchar

- char 是定长字符串，varchar 是变长字符串。

- char 在存储时会在右边填充空格以达到指定的长度，检索时去掉空格，varchar 在存储时需要额外的 1 或 2 个字节记录字符串的长度，检索时不需要处理

- char 更适合存储长度较短或长度差不多的字符串，varchar 适合存储长度不确定或差异大的字符串

### datetime vs timestamp 

- datetime 没有时区信息，timestamp 与时区有关，会根据时区改变时间

- datetime 需要 8 个字节，timestamp4 个字节

### NULL vs ''

- `NULL` 代表一个不确定的值, 就算是两个 `NULL`, 它俩也不一定相等。例如，`SELECT NULL=NULL` 的结果为 false，但是在我们使用 `DISTINCT`, `GROUP BY`, `ORDER BY` 时, `NULL` 又被认为是相等的。
- `''` 的长度是 0，是不占用空间的，而 `NULL` 是需要占用空间的。
- `NULL` 会影响聚合函数的结果。例如，`SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值。 `COUNT` 的处理方式取决于参数的类型。如果参数是 `*`(`COUNT(*)`)，则会统计所有的记录数，包括 `NULL` 值；如果参数是某个字段名(`COUNT(列名)`)，则会忽略 `NULL` 值，只统计非空值的个数。
- 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULLl` 来判断，而不能使用 =、!=、 <、> 之类的比较运算符。而 `''` 是可以使用这些比较运算符的

## MySQL 基础架构

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1711774066_0.png" alt="13526879-3037b144ed09eb88" style="zoom:67%;" />

- **连接器：** 身份认证和权限相关(登录 MySQL 的时候)。
- **查询缓存：** 执行查询语句的时候，会先查询缓存(MySQL 8.0 版本后移除，因为这个功能不太实用)。
- **分析器：** 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
- **优化器：** 按照 MySQL 认为最优的方案去执行
- **执行器：** 执行语句，然后从存储引擎返回数据

![13526879-3037b144ed09eb88](https://raw.githubusercontent.com/Moriic/picture/main/image/1711785332_0.png)

- **连接器：** 身份认证和权限相关(登录 MySQL 的时候)。
- **查询缓存：** 执行查询语句的时候，会先查询缓存(MySQL 8.0 版本后移除，因为这个功能不太实用)。
- **分析器：** 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
- **优化器：** 按照 MySQL 认为最优的方案去执行。
- **执行器：** 执行语句，然后从存储引擎返回数据。

简单来说 MySQL 主要分为 Server 层和存储引擎层：

- **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。
- **存储引擎**：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了**

### 连接器

​    主要 **负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作**，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开 **，即使管理员修改了该用户的权限，该用户也是不受影响的**。

### 查询缓存(8.0 后移除)

查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。

连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。

MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。

### 分析器

分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：

1. **词法分析**，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。
2. **语法分析**，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。

### 优化器

化器的作用就是它认为的最优的执行方案去执行(有时候可能也不是最优)

### 执行器

当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果

### 执行流程

`select * from tb_student  A where A.age='18' and A.name=' 张三 ';`

1. 检查权限，检查缓存(8.0 前)
2. 词法分析，提取 SQL 语句的关键元素，语法分析，是否有语法错误
3. 优化器，选择最优的方案准备执行
4. 权限校验，调用数据库引擎执行结果

`update tb_student A set A.age='19' where A.name=' 张三 ';`

执行更新要记录日志，日志模块 binlog(归档日志)，InnoDB 引擎还自带 redo log(重做日志)

1. 查询张三的数据
2. 拿到查询的语句，把 age 改为 19，调用引擎写入这行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成，随时可以提交
3. 执行器收到通知后记录 binlog，调用引擎接口，提交 redo log 为提交状态

为什么要两个日志：redo log 来支持事务

为什么 redo log 要引入 prepare 预提交状态：

- 先写 redo log 直接提交，然后写 binlog：写完 redo log 后机器挂了，binlog 日志没写入，重启后，使用 redo log 恢复数据，binlog 没有该记录，后续备份会丢失该记录，主从同步也会丢失
- 先写 binlog，后写 redo log：写完 binlog 后机器异常重启，redo log 不会恢复，而 binlog 有记录，会数据不一致
- 两个阶段，redo log 处于 prepare 状态，写完 binlog 后，若异常重启，MySQL 判断 redo log 是否完整，则提交，如果 redo log 处于 prepare 状态，先判断 binlog 是否完整，完整则提交 redo log，不完整就回滚数据

### 总结

- MySQL 主要分为 **Server 层和引擎层**，Server 层主要包括**连接器、查询缓存、分析器、优化器、执行器**，同时还有一个日志模块(binlog)，这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。
- 引擎层是插件式的，目前主要包括，MyISAM, InnoDB, Memory 等。
- **查询语句**的执行流程如下：**权限校验(如果命中缓存) ---> 查询缓存 ---> 分析器 ---> 优化器 ---> 权限校验 ---> 执行器 ---> 引擎**
- **更新语句**执行流程如下：**分析器 ---> 权限校验 ---> 执行器 ---> 引擎 ---> redo log(prepare 状态)---> binlog ---> redo log(commit 状态)**

