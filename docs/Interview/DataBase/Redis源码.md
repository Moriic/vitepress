# Redis 源码

## String SDS

> [Redis SDS 详解](https://zhuanlan.zhihu.com/p/615174662)

### 特性

- String 是最基本的 Redis 数据类型；
- String 是二进制安全，存入和获取的数据相同；
- Redis 字符串存储字节序列，包括文本、序列化对象和二进制数组；
- String 存储的 value 值最大为 512MB；

### 存储结构

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1712201094_0.webp" alt="v2-7f4d7cd708fa71cb37083b1566451420_1440w" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1712201211_0.webp" alt="v2-068fb4179343c0f2c9f8fe50306e29dd_1440w" style="zoom:50%;" />

SDS 各个属性说明：

1. len：表示 buf 已用空间的长度，占 4 个字节，不包括 '\0'；
2. alloc：表示 buf 的实际分配长度，占 4 个字节，不包括 '\0'；
3. flags：标记当前字节数组是 sdshdr8/16/32/64 中的哪一种，占 1 个字节；
4. buf：表示字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个'\0'，需要额外占用 1 个字节的开销

### SDS vs cstring

- **可以避免缓冲区溢出**：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。

- **获取字符串长度的复杂度较低**：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。
- **减少内存分配次数**：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。

- **二进制安全**：C 语言中的字符串以空字符 `\0` 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。

![v2-01ca8d47ea71bdc5fa6d136d8f4bdc24_1440w](https://raw.githubusercontent.com/Moriic/picture/main/image/1712201523_0.webp)

## Zset 跳表

Set 有两种不同的实现，分别是 ziplist 和 skiplist，具体使用哪种结构进行存储的规则如下：

- 当有序集合对象同时满足以下两个条件时，使用 ziplist： 
  1. ZSet 保存的键值对数量少于 128 个；
  2. 每个元素的长度小于 64 字节。
- 如果不满足上述两个条件，那么使用 skiplist

### 跳表

有序链表在添加、查询、删除的平均时间复杂都都是 **O(n)即线性增长，所以一旦节点数量达到一定体量后其性能表现就会非常差劲。而跳表我们完全可以理解为在原始链表基础上，建立多级索引，通过多级索引检索定位将增删改查的时间复杂度变为O(log n)**。

![202401222005524](https://raw.githubusercontent.com/Moriic/picture/main/image/1712215077_0.png)

理想情况是每一层索引是下一层元素个数的二分之一， k 层索引的元素个数 r 计算公式为: r=n/2^k
