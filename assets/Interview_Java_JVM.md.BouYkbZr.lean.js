import{_ as i,c as l,a2 as s,o as t}from"./chunks/framework.DPuwY6B9.js";const c=JSON.parse('{"title":"JVM","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/Java/JVM.md","filePath":"Interview/Java/JVM.md"}'),e={name:"Interview/Java/JVM.md"};function r(o,a,n,h,p,g){return t(),l("div",null,a[0]||(a[0]=[s(`<h1 id="jvm" tabindex="-1">JVM <a class="header-anchor" href="#jvm" aria-label="Permalink to &quot;JVM&quot;">​</a></h1><h2 id="基础概念" tabindex="-1">基础概念 <a class="header-anchor" href="#基础概念" aria-label="Permalink to &quot;基础概念&quot;">​</a></h2><h3 id="功能" tabindex="-1">功能 <a class="header-anchor" href="#功能" aria-label="Permalink to &quot;功能&quot;">​</a></h3><ul><li><strong>解释与运行</strong>：对字节码文件中的指令，实时解释成机器码，让计算机执行</li><li><strong>内存管理</strong>：自动为对象，方法等分配内存，自动的垃圾回收机制</li><li><strong>即时编译</strong>：对热点代码进行优化，将热点代码的机器码存放到内存中(JIT)</li></ul><h3 id="jdk-vs-jre-vs-jvm" tabindex="-1">JDK vs JRE vs JVM <a class="header-anchor" href="#jdk-vs-jre-vs-jvm" aria-label="Permalink to &quot;JDK vs JRE vs JVM&quot;">​</a></h3><ul><li><strong>JRE</strong>：Java 运行时环境和必要的类库</li><li><strong>JDK</strong>：包含 JRE 及 javac(编译器)，jdb(调试器)</li><li><strong>JVM</strong>：运行字节码的虚拟机</li></ul><h3 id="jvm-组成" tabindex="-1">JVM 组成 <a class="header-anchor" href="#jvm-组成" aria-label="Permalink to &quot;JVM 组成&quot;">​</a></h3><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714635236_0.png" alt="image-20240502153355826" style="zoom:50%;"><h2 id="字节码文件" tabindex="-1">字节码文件 <a class="header-anchor" href="#字节码文件" aria-label="Permalink to &quot;字节码文件&quot;">​</a></h2><h3 id="组成" tabindex="-1">组成 <a class="header-anchor" href="#组成" aria-label="Permalink to &quot;组成&quot;">​</a></h3><ul><li><strong>基本信息</strong>：魔数、字节码文件对应的 Java 版本号，访问标识(public final 等)，父类和接口</li><li><strong>常量池</strong>：保存了字符串常量，类或接口名、字段名，主要在字节码指令中使用</li><li><strong>字段</strong>：当前类或接口声明的字段信息</li><li><strong>方法</strong>：当前类或接口声明的方法信息，字节码指令</li><li><strong>属性</strong>：类的属性，如源码的文件名，内部类的列表等</li></ul><blockquote><p>通过文件的头几个字节去校验文件的类型，如 Java 字节码文件的文件头为 CAFEBABE，称为 magic 魔数</p></blockquote><h3 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h3><ul><li><p>javap：javap -v 字节码文件路径 &gt; 输出路径 (jar -xvf 解压 jar 包)</p></li><li><p>jclasslib 插件</p></li><li><p>阿里 arthas：<a href="https://arthas.aliyun.com/" target="_blank" rel="noreferrer">https://arthas.aliyun.com/</a></p><ul><li>dump -d 目标路径 字节码路径：查看字节码文件</li><li>jad 文件路径：反编译源代码</li></ul></li></ul><h2 id="类的生命周期" tabindex="-1">类的生命周期 <a class="header-anchor" href="#类的生命周期" aria-label="Permalink to &quot;类的生命周期&quot;">​</a></h2><p>加载 -&gt; 连接 (验证 -&gt; 准备 -&gt; 解析) -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p><h3 id="加载阶段" tabindex="-1">加载阶段 <a class="header-anchor" href="#加载阶段" aria-label="Permalink to &quot;加载阶段&quot;">​</a></h3><ul><li>类加载器根据类的全限类名通过不同的渠道以二进制的方式 <strong>加载字节码信息</strong></li><li>加载完后，JVM 将字节码中的信息保存在 <strong>内存的方法区</strong> 中，生成一个 <strong>InstanceKlass</strong> 对象，保存 <strong>字节码文件的所有信息</strong>，包含实现特定功能的信息如多态的信息(c++语言)</li><li>JVM 还会在 <strong>堆中</strong> 生成一份与方法区中的数据类似的 <strong>java.lang.Class 对象</strong>，作用是在 Java 代码中去获取类的信息(反射)以及存储静态字段的数据(JDK8 及以后)，<strong>字段/方法(静态字段)</strong></li></ul><blockquote><ul><li><p>推荐使用 JDK 自带的 hsdb 工具查看 Java 虚拟机内存信息。</p></li><li><p>工具位于 JDK 安装目录下 lib 文件夹中的 sa-jdijar 中。启动命令：java -cp sa-jdi.jar sun.jvm.hotspot.HSDB</p></li><li><p>jps 查看运行进程 pid</p></li></ul></blockquote><h3 id="连接阶段" tabindex="-1">连接阶段 <a class="header-anchor" href="#连接阶段" aria-label="Permalink to &quot;连接阶段&quot;">​</a></h3><ul><li><strong>验证</strong>：检测 Java 字节码文件的 <strong>规范约束</strong></li><li><strong>准备：为静态变量(static)分配内存并设置初始值，final 会直接赋值</strong></li><li><strong>解析</strong>：将常量池中的符号应用替换为 <strong>直接引用(内存地址)</strong></li></ul><h3 id="初始化阶段" tabindex="-1">初始化阶段 <a class="header-anchor" href="#初始化阶段" aria-label="Permalink to &quot;初始化阶段&quot;">​</a></h3><ul><li><strong>执行静态代码块中的代码，并为静态变量赋值</strong></li><li>执行字节码文件中 clinit 部分的字节码指令(按 java 编写顺序一致)</li></ul><p>导致类的初始化：</p><ul><li>访问一个类的 <strong>静态变量或静态方法</strong>，注意变量是 final 修饰并且等号 <strong>右边是常量</strong> 不会触发初始化，在准备阶段初始化</li><li>调用 <strong>Class.forName(String className)</strong></li><li><strong>new</strong> 一个该类的对象</li><li>执行 Main 方法的当前类</li></ul><blockquote><p>-XX:+TraceClassLoading 参数可以打印出加载并初始化的类</p></blockquote><p>注意：</p><ul><li>直接访问父类的静态变量，触发父类的初始化，不会触发子类的初始化</li><li>子类的初始化调用之前，会 <strong>先初始化父类</strong></li><li>数组的创建不会导致数组中元素的类进行初始化</li><li>final 修饰的变量如果赋值的内容需要执行指令才能得出结果，会在初始化阶段进行初始化，而不是在准备阶段，如 <code>Integer.valueOf(1)</code></li></ul><h2 id="类加载器" tabindex="-1">类加载器 <a class="header-anchor" href="#类加载器" aria-label="Permalink to &quot;类加载器&quot;">​</a></h2><h3 id="类加载器的分类" tabindex="-1">类加载器的分类 <a class="header-anchor" href="#类加载器的分类" aria-label="Permalink to &quot;类加载器的分类&quot;">​</a></h3><ul><li><p><strong>虚拟机底层实现(C++ Hotspot)</strong>：加载程序运行时的基础类，如 java.lang.String，启动类加载器 BootStrap</p></li><li><p><strong>扩展类加载器(Java)</strong>：继承自抽象类 ClassLoader，扩展类加载器 Extension，应用程序类加载器 Application</p></li><li><p><strong>BootStrapClassLoader</strong>：加载 /jre/lib 下的文件，使用 <code>-Xbootclasspath/a:jar包目录/jar包名</code></p></li><li><p><strong>ExtClassLoader</strong>：加载 /jre/lib/ext 下的文件，使用 <code>-Djava.ext.dirs=jar包目录</code>(; 分隔)</p></li><li><p><strong>AppClasssloader</strong>：加载 classpath 下的类文件</p></li></ul><h3 id="双亲委派机制" tabindex="-1">双亲委派机制 <a class="header-anchor" href="#双亲委派机制" aria-label="Permalink to &quot;双亲委派机制&quot;">​</a></h3><p>当一个类加载器接收到加载类的任务时，会 <strong>自底向上查找是否加载过，再自顶向下进行加载</strong></p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714655278_0.png" alt="image-20240502210755475" style="zoom:50%;"><p>使用指定类加载器加载：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ClassLoader classLoader </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Demo2.class.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Class&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; stringClazz </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> classLoader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;java.lang.String&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><blockquote><ol><li><p>当一个类加载器去加载某个类的时候，会自底向上查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由顶向下进行加载。</p></li><li><p>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器。</p></li><li><p>双亲委派机制的好处有两点：第一是避免恶意代码替换 JDK 中的核心类库，比如 java.lang.String，确保核心类库的完整性和安全性。第二是避免一个类重复地被加载。</p></li></ol></blockquote><h3 id="打破双亲委派机制" tabindex="-1">打破双亲委派机制 <a class="header-anchor" href="#打破双亲委派机制" aria-label="Permalink to &quot;打破双亲委派机制&quot;">​</a></h3><p>自定义类加载器：Tomcat</p><p>重写 loadClass 方法，将双亲委派机制的代码去除</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714659115_0.png" alt="image-20240502221155014" style="zoom:50%;"><p>线程上下文类加载器(AppClassLoader)：JDBC</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714659945_0.png" alt="image-20240502222545631" style="zoom:50%;"><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ClassLoader c1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getContextClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//获取</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setContextClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(classLoader);       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置</span></span></code></pre></div><h2 id="运行时数据区" tabindex="-1">运行时数据区 <a class="header-anchor" href="#运行时数据区" aria-label="Permalink to &quot;运行时数据区&quot;">​</a></h2><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714200206_0.png" alt="image-20240427144325875" style="zoom:67%;"><h3 id="程序计数器" tabindex="-1">程序计数器 <a class="header-anchor" href="#程序计数器" aria-label="Permalink to &quot;程序计数器&quot;">​</a></h3><p>PC 寄存器，记录下一条指令的地址，线程不共享，保证线程切换时能回到之前的位置</p><h3 id="java-虚拟机栈" tabindex="-1">Java 虚拟机栈 <a class="header-anchor" href="#java-虚拟机栈" aria-label="Permalink to &quot;Java 虚拟机栈&quot;">​</a></h3><p>每个方法调用使用栈帧保存，随着线程创建而创建，销毁而销毁</p><h3 id="栈帧" tabindex="-1">栈帧 <a class="header-anchor" href="#栈帧" aria-label="Permalink to &quot;栈帧&quot;">​</a></h3><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714707207_0.png" alt="image-20240503113327101" style="zoom:50%;"><ul><li><strong>局部变量表</strong>：对象 this，方法参数，局部变量</li><li><strong>操作数栈</strong>：存放执行指令过程中需要的临时数据</li><li><strong>动态链接</strong>：指向运行时常量池的方法引用</li><li><strong>方法返回地址</strong>：方法正常退出或异常退出的地址</li></ul><p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714708013_0.jpg" alt="0082zybply1gca4k4gndgj31d20o2td0"></p><h3 id="栈内存溢出" tabindex="-1">栈内存溢出 <a class="header-anchor" href="#栈内存溢出" aria-label="Permalink to &quot;栈内存溢出&quot;">​</a></h3><ul><li>栈帧过多，导致 StackOverflow 错误</li><li>-Xss 栈大小(默认 1M)</li></ul><h3 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to &quot;堆&quot;">​</a></h3><ul><li><p>创建的对象存在于堆中</p></li><li><p>栈上的局部变量表，可以存放堆上的对象的引用，静态变量也可以存放堆对象的引用，线程共享</p></li><li><p>堆溢出 OutOfMemory，-Xmx(max 最大值) -Xms(初始 total)</p></li></ul><h3 id="方法区" tabindex="-1">方法区 <a class="header-anchor" href="#方法区" aria-label="Permalink to &quot;方法区&quot;">​</a></h3><ul><li>类的基本信息：InstanceKlass，加载阶段完成</li><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code> 方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</li><li>JDK7-永久代(堆中，-XX: MaxPermSize =?)，JDK8-元空间(操作系统直接内存，-XX: MaxMetaspaceSize =?)</li></ul><h2 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h2><h3 id="方法区的回收" tabindex="-1">方法区的回收 <a class="header-anchor" href="#方法区的回收" aria-label="Permalink to &quot;方法区的回收&quot;">​</a></h3><p>类可以被回收，需要满足三个条件：</p><ol><li><p>此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。</p></li><li><p>加载该类的类加载器已经被回收</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用</p></li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">URLClassLoader loader </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> URLClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;file:D:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">lib</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Class&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; clazz </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadclass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;com.itheima.my.A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object o </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clazz.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="引用计数法" tabindex="-1">引用计数法 <a class="header-anchor" href="#引用计数法" aria-label="Permalink to &quot;引用计数法&quot;">​</a></h3><ul><li>为每个对象维护一个引用计数器，引用时加 1，取消引用时减 1</li><li>循环引用会导致无法回收</li></ul><h3 id="可达性分析法" tabindex="-1">可达性分析法 <a class="header-anchor" href="#可达性分析法" aria-label="Permalink to &quot;可达性分析法&quot;">​</a></h3><ul><li>将对象分为两类：垃圾回收的根对象(GC Root) 和 普通对象</li><li>如果从某个对象到某个 GC Root 可达，则不可回收</li></ul><p>GC Root 对象：</p><ul><li>线程 Thread 对象，引用线程栈帧中的方法参数，局部变量</li><li>系统类加载器加载的 java.lang.Class 对象，引用类中的静态变量</li><li>监视器对象，用来保存同步锁 synchronized 关键词持有的对象</li><li>本地方法调用时使用的全局对象</li></ul><h3 id="五种对象引用" tabindex="-1">五种对象引用 <a class="header-anchor" href="#五种对象引用" aria-label="Permalink to &quot;五种对象引用&quot;">​</a></h3><ul><li><strong>强引用</strong>：到 GC Root 可达</li><li><strong>软引用</strong>：常用于缓存中，SoftReference 引用的对象，当内存不足会回收</li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714810438_0.png" alt="image-20240504161356296" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714810830_0.png" alt="image-20240504162029761" style="zoom:50%;"><ul><li><strong>弱引用</strong>：在垃圾回收时，不管内存够不够都会回收，主要用于 ThreadLocal，WeekReference</li><li><strong>虚引用</strong>：不能通过虚引用对象获取到包含的对象，唯一用途是当对象被垃圾回收时可以接收到对应的通知，直接内存回收</li><li><strong>终结器引用</strong>：在对象需要被回收时，终结器引用会关联对象并放置在 Finalizer 类的引用队列中，执行 finalize 方法后二次回收</li></ul><h3 id="垃圾回收算法" tabindex="-1">垃圾回收算法 <a class="header-anchor" href="#垃圾回收算法" aria-label="Permalink to &quot;垃圾回收算法&quot;">​</a></h3><p>垃圾回收通过单独的 GC 线程完成，会有部分阶段需要停止所有的用户线程，这个过程被称之为 STW(Stop The World)</p><blockquote><p>-verbose: gc 打印垃圾回收日志</p></blockquote><h4 id="标记-清除算法" tabindex="-1">标记 - 清除算法 <a class="header-anchor" href="#标记-清除算法" aria-label="Permalink to &quot;标记 - 清除算法&quot;">​</a></h4><ol><li><strong>标记阶段</strong>：将所有存活的对象进行标记，Java 使用可达性分析算法，从 GC Root 通过引用链遍历出所有存活对象</li><li><strong>清除阶段</strong>：从内存中删除没有被标记的对象</li></ol><p><strong>缺点</strong>：碎片化，分配速度慢(需要维护空闲链表指向碎片空间)</p><h4 id="复制算法" tabindex="-1">复制算法 <a class="header-anchor" href="#复制算法" aria-label="Permalink to &quot;复制算法&quot;">​</a></h4><ol><li>准备两块对象 From 和 To 空间，对象分配阶段，创建对象到 From 空间</li><li>GC 阶段开始，将 GC Root 及其关联对象搬运到 To 空间</li><li>清理 From 空间，并将名称互换</li></ol><p><strong>优点</strong>：吞吐量高，但不如标记清除算法，不会发生碎片化</p><p><strong>缺点</strong>：内存效率低，只有一半</p><h4 id="标记-整理算法" tabindex="-1">标记 - 整理算法 <a class="header-anchor" href="#标记-整理算法" aria-label="Permalink to &quot;标记 - 整理算法&quot;">​</a></h4><p>标记压缩算法，对内存碎片化进行优化：</p><ol><li>标记阶段：将所有存活对象进行标记</li><li>整理阶段：将存活对象移动到内存的一端，清理掉非存活对象的空间</li></ol><p><strong>优点</strong>：内存使用效率高，不会发生碎片化</p><p><strong>缺点</strong>：整理效率低</p><h4 id="分代算法" tabindex="-1">分代算法 <a class="header-anchor" href="#分代算法" aria-label="Permalink to &quot;分代算法&quot;">​</a></h4><p>组合使用上面算法，将整个内存划分为年轻代(Eden, s0, s1)和老年代</p><ul><li><p>新生代使用: 复制算法</p></li><li><p>老年代使用: 标记 - 清除 或者 标记 - 整理 算法</p></li><li><p>创建对象，首先放入 Eden 区，当 Eden 区满时，触发 Minor GC</p></li><li><p>Minor GC 将 Eden 和 From 区需要回收的对象回收，没有回收的放入 To 区，并名称互换</p></li><li><p>每次 Minor GC 会将对象的年龄 +1，初始为 0，当达到阈值(最大 15)时，会将对象放入老年代</p></li><li><p>当老年代区满时，触发 Full GC</p></li><li><p>如果 Minor GC 和 Full GC 都无法回收空间，且需要放入新对象，会 OutOfMemory，两个都会 STW</p></li></ul><h3 id="垃圾回收器" tabindex="-1">垃圾回收器 <a class="header-anchor" href="#垃圾回收器" aria-label="Permalink to &quot;垃圾回收器&quot;">​</a></h3><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714829660_0.png" alt="image-20240504213417894" style="zoom:50%;"><h4 id="年轻代-serial-老年代-serialold-垃圾回收器" tabindex="-1">年轻代-Serial / 老年代-SerialOld 垃圾回收器 <a class="header-anchor" href="#年轻代-serial-老年代-serialold-垃圾回收器" aria-label="Permalink to &quot;年轻代-Serial / 老年代-SerialOld 垃圾回收器&quot;">​</a></h4><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714829808_0.png" alt="image-20240504213647924" style="zoom:50%;"><blockquote><p>-XX:+UseSerialGC，新生代，老年代都使用串行回收器</p></blockquote><p>一种 <strong>单线程串行回收年轻代</strong> 的垃圾回收器，<strong>复制算法</strong></p><ul><li><p>优点：单 CPU 处理器吞吐量出色</p></li><li><p>缺点：多 CPU 吞吐量不如其他垃圾回收器，堆偏大会导致 STW 时间过长</p></li></ul><h4 id="年轻代-parnew" tabindex="-1">年轻代-ParNew <a class="header-anchor" href="#年轻代-parnew" aria-label="Permalink to &quot;年轻代-ParNew&quot;">​</a></h4><p>ParNew 使用 <strong>多线程进行垃圾回收</strong></p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714830171_0.png" alt="image-20240504214250930" style="zoom:67%;"><ul><li>优点：多 CPU 处理器停顿时间短</li><li>缺点：吞吐量和停顿时间不如 G1 回收器</li></ul><blockquote><p>-XX:+UserParNewGC 新生代使用 ParNew 回收器，老年代使用串行回收器</p></blockquote><h4 id="老年代-cms-垃圾回收器" tabindex="-1">老年代-CMS 垃圾回收器 <a class="header-anchor" href="#老年代-cms-垃圾回收器" aria-label="Permalink to &quot;老年代-CMS 垃圾回收器&quot;">​</a></h4><p>CMS <strong>关注系统的暂停时间，允许用户线程和回收线程同时执行，标记-清除算法</strong>，内存碎片会在 Full GC 处理，会导致用户现场的暂停</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714830228_0.png" alt="image-20240504214348467" style="zoom:50%;"><ol><li><strong>初始标记</strong>：标记 GC Root 直接关联的对象</li><li><strong>并发标记</strong>：标记所有的对象，并发</li><li><strong>重新标记</strong>：标记并发标记中的对象</li><li><strong>并发清理</strong>：清理未标记的对象</li></ol><ul><li>优点：同时执行，用户体验好</li><li>缺点：内存碎片，<strong>浮动垃圾(并发时产生的垃圾)</strong></li><li>如果老年代内存不足分配对象，CMS 会退化成 Serial Old 回收老年代</li></ul><blockquote><p>-XX:+UseConcMarkSweepGC 新生代使用 ParNew，老年代使用 CMS</p></blockquote><h4 id="年轻代-ps-老年代-po" tabindex="-1">年轻代-PS / 老年代-PO <a class="header-anchor" href="#年轻代-ps-老年代-po" aria-label="Permalink to &quot;年轻代-PS / 老年代-PO&quot;">​</a></h4><p>Parallel Scavenge 是 JDK8 <strong>默认的年轻代垃圾回收器</strong>，<strong>多线程并行回收，关注的是系统的吞吐量</strong>。具备 <strong>自动调整堆内存大小</strong> 的特点。复制算法</p><ul><li>优点：吞吐量高，手动可控，动态调整堆的参数</li><li>缺点：STW</li></ul><p>Parallel Old 老年代多线程并发收集，<strong>标记整理算法</strong></p><ul><li>优点：多核并发高</li><li>缺点：STW</li></ul><blockquote><p>-XX: UseParallelGC 或 -XX: UseParallelOldGC 使用 PS/PO 组合</p><p>-XX: MaxGCPauseMillis = n，设置最大停顿时间，</p><p>-XX: GCTimeRatio = n，设置吞吐量为 n（用户线程执行时间 = n/n + 1）</p><p>-XX: UseAdaptiveSizePolicy，设置自动调整堆大小</p></blockquote><h4 id="g1-垃圾回收器" tabindex="-1">G1 垃圾回收器 <a class="header-anchor" href="#g1-垃圾回收器" aria-label="Permalink to &quot;G1 垃圾回收器&quot;">​</a></h4><p>JDK9 后默认垃圾回收器</p><ol><li><p>支持巨大的堆空间回收，并有较高的吞吐量</p></li><li><p>支持多 CPU 并行垃圾回收</p></li><li><p>允许用户设置最大暂停时间</p></li></ol><p>G1 的整个堆会被划分成多个大小相等的区域，称之为区 Region，区域不要求是连续的。分为 Eden、Survivor、Old 区。Region 的大小通过堆空间大小/2048 计算得到，也可以通过参数-XX: G1HeapRegionSize = 32m 指定(其中 32m 指定 region 大小为 32M)，Region size 必须是 2 的指数幂，取值范围从 1M 到 32M。</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1714833683_0.png" alt="image-20240504224123392" style="zoom:50%;"><p><strong>年轻代回收（Young GC）：回收 Eden 区和 Survivor 区中不用的对象。</strong> 会导致 STW，G1 中可以通过参数-XX: MaxGCPauseMillis = n（默认 200）设置每次垃圾回收时的最大暂停时间毫秒数，G1 垃圾回收器会尽可能地保证暂停时间。</p><ol><li>新创建的对象会存放在 Eden 区。当 G1 判断年轻代区不足（max 默认 60%），无法分配对象时需要回收时会执行 Young GC.</li><li><strong>标记出 Eden 和 Survivor 区域中的存活对象</strong></li><li>根据配置的最大暂停时间选择某些区域 <strong>将存活对象复制到一个新的 Survivor 区中（年龄+1），清空这些区域</strong>。</li><li>G1 在进行 YoungGC 的过程中会去记录每次垃圾回收时每个 Eden 区和 Survivor 区的平均耗时，以作为下次回收时的参考依据。这样就可以 <strong>根据配置的最大暂停时间计算出本次回收时最多能回收多少个 Region 区域</strong> 了。比如-XX: MaxGCPauseMillis = n（默认 200），每个 Region 回收耗时 40ms，那么这次回收最多只能回收 4 个 Region。</li><li>后续 YoungGC 时与之前相同，只不过 Survivor 区中存活对象会被搬运到另一个 Survivor 区。</li><li>当某个 <strong>存活对象的年龄到达阈值（默认 15），将被放入老年代</strong>。</li><li><strong>部分对象如果大小超过 Region 的一半</strong>，会直接放入老年代，这类老年代被称为 Humongous 区。比如堆内存是 4G，每个 Region 是 2M，只要一个大对象超过了 1M 就被放入 Humongous 区，如果对象过大会横跨多个 Region。</li><li>多次回收之后，会出现很多 Old 老年代区，此时总堆占有率达到阈值时（-XX: InitiatingHeap0ccupancyPercent 默认 45%）会触发 <strong>混合回收 MixedGC</strong>。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成。</li></ol><p><strong>混合回收(MixedGC)：</strong></p><p>混合回收分为：初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark 或者 FinalizeMarking）、并发清理(cleanup) <strong>复制算法</strong></p><p>G1 对 <strong>老年代的清理</strong> 会 <strong>选择存活度最低的区域来进行回收</strong>，这样可以保证回收效率最高，这也是 G1（Garbagefirst）名称的由来。</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1715865548_0.png" alt="image-20240516211906533" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1715865654_0.png" alt="image-20240516212054048" style="zoom:50%;"><p>如果清理过程中发现没有足够的空 Region 存放转移的对象，会出现 FullGC。单线程执行标记-整理算法，此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。</p><blockquote><p>-XX:+UseG1GC，打开 G1 -XX: MaxGCPauseMills，最大暂停时间</p></blockquote><p>优点：对比较大的堆如超过 6G 的堆回收时，延迟可控，不会产生垃圾碎片，并发标记的 SATB 算法效率高</p><h2 id="实战" tabindex="-1">实战 <a class="header-anchor" href="#实战" aria-label="Permalink to &quot;实战&quot;">​</a></h2><h3 id="基础概念-1" tabindex="-1">基础概念 <a class="header-anchor" href="#基础概念-1" aria-label="Permalink to &quot;基础概念&quot;">​</a></h3><p><strong>内存泄漏</strong>：在 Java 中如果不再使用一个对象，但是该对象仍在 GC ROOT 的引用链上，这个对象就不会被垃圾回收器回收</p><p><strong>内存溢出</strong>：是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory</p><h3 id="排查问题" tabindex="-1">排查问题 <a class="header-anchor" href="#排查问题" aria-label="Permalink to &quot;排查问题&quot;">​</a></h3><ul><li><strong>top 命令</strong>：查看内存信息 RES(常驻内存)，SHA(共享内存)，MEM(内存占用)，默认按 CPU 排序，按下 M 后按 MEM 排序</li><li><strong>jvisualvm</strong>：java 自带可视化</li><li><strong>Arthas</strong>：tunnel 隧道服务管理所有需要监控的程序</li></ul><h3 id="内存泄漏原因" tabindex="-1">内存泄漏原因 <a class="header-anchor" href="#内存泄漏原因" aria-label="Permalink to &quot;内存泄漏原因&quot;">​</a></h3><ol><li>不正确的 equals()和 hashCode()：Map 同一对象映射到不同地方，导致存在多个对象无法垃圾回收</li><li>内部类引用外部类</li><li>ThreadLocal 的使用：使用创建线程不会内存泄漏，使用线程池不 remove 会内存泄漏</li><li>String 的 intern 方法：JDK6 中字符串常量池放在永久代中，JDK放在堆中，保存大量字符串并被引用无法回收会内存溢出</li><li>通过静态字段保存对象</li><li>资源没有正常关闭</li></ol>`,141)]))}const u=i(e,[["render",r]]);export{c as __pageData,u as default};
