import{_ as e,c as i,o as r,a2 as t}from"./chunks/framework.CalKHhbg.js";const d=JSON.parse('{"title":"Java","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/Review/Java.md","filePath":"Interview/Review/Java.md"}'),l={name:"Interview/Review/Java.md"};function o(n,a,p,c,s,h){return r(),i("div",null,a[0]||(a[0]=[t('<h1 id="java" tabindex="-1">Java <a class="header-anchor" href="#java" aria-label="Permalink to &quot;Java&quot;">​</a></h1><h2 id="序列化和反序列化" tabindex="-1">序列化和反序列化 <a class="header-anchor" href="#序列化和反序列化" aria-label="Permalink to &quot;序列化和反序列化&quot;">​</a></h2><p>序列化：将对象转为字节流，可通过网络传输、持久化存储和缓存，implements Serializable</p><p>反序列化：字节流转为对象，从存储中读取数据并重新创建对象</p><p>transient：标记不需要序列化的字段，如敏感数据</p><p>serialVersionUID：控制版本是否兼容，向后兼容则不变</p><p>序列化不包含静态变量</p><h2 id="不可变类" tabindex="-1">不可变类 <a class="header-anchor" href="#不可变类" aria-label="Permalink to &quot;不可变类&quot;">​</a></h2><p>创建后不能被修改</p><ul><li>声明类为 final，无法继承</li><li>字段为 private final，初始化后无法修改</li><li>不暴露 set 方法，修改时返回新对象</li><li>不可变类有：String，Integer，BigDecimal，LocalDate</li></ul><p>优点：</p><ul><li>线程安全</li><li>缓存友好：如 String 的字符串常量池</li><li>防止状态不一致</li></ul><p>缺点：</p><ul><li>性能问题：每次状态变化都需要创建新的对象，如 String 的频繁拼接</li></ul><h3 id="exception-和-error" tabindex="-1">Exception 和 Error <a class="header-anchor" href="#exception-和-error" aria-label="Permalink to &quot;Exception 和 Error&quot;">​</a></h3><p>Exception：程序可以处理的异常，又分为 编译器异常 和 运行时异常</p><p>Error：无法通过代码处理，如OOM，SOF</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1729587286_0.png" alt="image-20241022165445535" style="zoom:50%;"><h2 id="多态" tabindex="-1">多态 <a class="header-anchor" href="#多态" aria-label="Permalink to &quot;多态&quot;">​</a></h2><p>对象可以通过父类或接口进行多态性调用，不同对象运行时执行不同的行为</p><p>编译时多态：静态多态，方法重载，同一个类存在多个同名方法</p><p>运行时多态：动态多态，方法重写，继承/实现接口时子类重写父类的方法，父类的引用指向子类的对象</p><h2 id="按值传递" tabindex="-1">按值传递 <a class="header-anchor" href="#按值传递" aria-label="Permalink to &quot;按值传递&quot;">​</a></h2><p>Java 使用按值传递</p><ul><li>基本数据类型：传递数值本身</li><li>引用数据类型：传递对象引用的内存地址，可以修改对象的内容</li></ul><h2 id="多重继承" tabindex="-1">多重继承 <a class="header-anchor" href="#多重继承" aria-label="Permalink to &quot;多重继承&quot;">​</a></h2><p>多重继承会出现菱形继承的问题，D 要调用 A 中的方法，无法知道调用 B 还是 C 的实现</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1729587882_0.png" alt="image-20241022170442584" style="zoom:33%;"><p>接口的多实现：</p><ul><li>子类必须实现接口中的所有方法，即只会调用自身方法</li><li>对于 default 默认方法，如果接口有相同的默认方法，子类必须重写</li></ul>',30)]))}const m=e(l,[["render",o]]);export{d as __pageData,m as default};
