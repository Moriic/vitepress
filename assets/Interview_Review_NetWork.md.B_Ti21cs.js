import{_ as a,c as e,o as i,a2 as r}from"./chunks/framework.CalKHhbg.js";const p=JSON.parse('{"title":"NetWork","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/Review/NetWork.md","filePath":"Interview/Review/NetWork.md"}'),l={name:"Interview/Review/NetWork.md"};function o(n,t,h,s,T,c){return i(),e("div",null,t[0]||(t[0]=[r('<h1 id="network" tabindex="-1">NetWork <a class="header-anchor" href="#network" aria-label="Permalink to &quot;NetWork&quot;">​</a></h1><h2 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-label="Permalink to &quot;基础&quot;">​</a></h2><h2 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h2><h3 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP/1.1&quot;">​</a></h3><ol><li><strong>长连接</strong>：完成一次请求后保持连接</li><li><strong>管道网络传输</strong>：不需要等待前一个请求的响应到达，可以发送第二次请求(不是默认开启)</li><li><strong>队头阻塞</strong>：前一个请求被阻塞时，后面的请求会被阻塞(没有管道传输)</li></ol><h3 id="http-2-0" tabindex="-1">HTTP/2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;HTTP/2.0&quot;">​</a></h3><ol><li><strong>头部压缩</strong>：使用静态表, Huffman 编码和动态表替换固定字段</li><li><strong>二进制格式</strong>：头信息和数据都是用二进制，称为帧，压缩长度</li><li><strong>并发传输</strong>：</li></ol><ul><li>1 个 TCP 连接包含多个 Stream</li><li>Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成</li><li>Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放</li><li>一个 HTTP 请求在同一个 Stream 中</li><li>不同 Stream 可以乱序发送，通过 StreamID 有序组装成 HTTP 消息，同一 Stream 内的帧必须有序</li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1729610774_0.webp" alt="image-20240105143239921" style="zoom:50%;"><ol start="4"><li><p><strong>服务器主动推送资源</strong>：在 Stream1 通知在哪个 Stream 中推送资源</p></li><li><p><strong>队头阻塞</strong>：TCP 需要保证收到的字节数据是连续的，当前一个字节数据没有到达时，后一个字节数据只能存放在内核缓冲区中，应用层无法接收</p></li></ol><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1729611079_0.webp" alt="http2阻塞" style="zoom:50%;"><h3 id="http-3-0" tabindex="-1">HTTP/3.0 <a class="header-anchor" href="#http-3-0" aria-label="Permalink to &quot;HTTP/3.0&quot;">​</a></h3><ol><li><strong>无队头阻塞</strong>：使用 QUIC 协议，某个流丢包时，只会阻塞这个流，其他流不会受到影响</li><li><strong>更快的建立连接</strong></li></ol><h3 id="http-状态码" tabindex="-1">HTTP 状态码 <a class="header-anchor" href="#http-状态码" aria-label="Permalink to &quot;HTTP 状态码&quot;">​</a></h3><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1729656042_0.webp" alt="6-五大类HTTP状态码" style="zoom:50%;"><h3 id="http-常见字段" tabindex="-1">HTTP 常见字段 <a class="header-anchor" href="#http-常见字段" aria-label="Permalink to &quot;HTTP 常见字段&quot;">​</a></h3><ul><li>Host 字段：指定服务器的域名</li><li>Content-Length 字段：指定数据长度，HTTP 通过设置回车作为 Header 的边界，通过 Content-Length 作为 HTTP body 的边界，解决粘包问题</li><li>Connection：Keep-Alive 使用 HTTP 长连接</li></ul><h3 id="get-post-区别" tabindex="-1">GET / POST 区别 <a class="header-anchor" href="#get-post-区别" aria-label="Permalink to &quot;GET / POST 区别&quot;">​</a></h3><ul><li>GET 用来从服务器获取指定的资源</li><li>POST 根据请求负载对指定的资源做出处理</li><li>GET 方法是幂等的，POST 是不安全，不幂等的</li></ul><h3 id="缓存技术" tabindex="-1">缓存技术 <a class="header-anchor" href="#缓存技术" aria-label="Permalink to &quot;缓存技术&quot;">​</a></h3><p>分为强制缓存和协商缓存</p><h3 id="http-和-https-区别" tabindex="-1">HTTP 和 HTTPS 区别 <a class="header-anchor" href="#http-和-https-区别" aria-label="Permalink to &quot;HTTP 和 HTTPS 区别&quot;">​</a></h3><ul><li>HTTP 是明文传输，存在安全问题，HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使报文加密传输</li><li>HTTP 建立只需要 TCP 三次握手，HTTPS 三次握手后还需要 SSL/TLS 握手</li><li>HTTP 端口是 80，HTTPS 是 443</li><li>HTTPS 需要向 CA 申请数字证书，保证服务器身份可信</li></ul><h3 id="https-过程" tabindex="-1">HTTPS 过程 <a class="header-anchor" href="#https-过程" aria-label="Permalink to &quot;HTTPS 过程&quot;">​</a></h3><ul><li>公钥加密，私钥解密：保证内容传输的安全</li><li>私钥加密，公钥解密：保证消息不会被冒充</li><li>通过哈希算法保证消息的完整性</li><li>通过数字签名(私钥加密，公钥解密)比对哈希值保证消息的来源可靠性</li><li>通过数字证书来保证服务器公钥的身份(确保公私钥不是伪造的)</li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1729658111_0.webp" alt="数字签名" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1729658126_0.webp" alt="22-数字证书工作流程" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1729658230_0.webp" alt="23-HTTPS工作流程" style="zoom:50%;"><h3 id="http-和-rpc" tabindex="-1">HTTP 和 RPC <a class="header-anchor" href="#http-和-rpc" aria-label="Permalink to &quot;HTTP 和 RPC&quot;">​</a></h3><p>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构，内部集群的微服务之间则采用 RPC 协议进行通讯</p><h2 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h2><h3 id="tcp-连接除了四次挥手断开外-还有什么断开连接的方式" tabindex="-1">TCP 连接除了四次挥手断开外，还有什么断开连接的方式？ <a class="header-anchor" href="#tcp-连接除了四次挥手断开外-还有什么断开连接的方式" aria-label="Permalink to &quot;TCP 连接除了四次挥手断开外，还有什么断开连接的方式？&quot;">​</a></h3><ul><li><p>如果主机需要尽快关闭连接（或连接超时，或端口、主机不可达）时，发送 RST 包（RST 表示复位）强制关闭 TCP 连接。</p></li><li><p>发送 RST 包关闭连接时，可以丢弃缓存区的包直接发送 RST 包，而接收端收到 RST 包后，也不必发送 ACK 包来确认。</p></li></ul>',33)]))}const m=a(l,[["render",o]]);export{p as __pageData,m as default};
