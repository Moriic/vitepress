import{_ as l,c as p,a2 as a,o as t}from"./chunks/framework.Gf1jShja.js";const g=JSON.parse('{"title":"操作系统","description":"","frontmatter":{},"headers":[],"relativePath":"School/OS.md","filePath":"School/OS.md"}'),s={name:"School/OS.md"};function n(e,i,m,o,u,c){return t(),p("div",null,i[0]||(i[0]=[a(`<img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719737256_0.png" alt="image-20240630164736431" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719737380_0.png" alt="image-20240630164940525" style="zoom:33%;"><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719737403_0.png" alt="image-20240630165003185" style="zoom:33%;"><p>生产者-消费者问题：</p><ul><li>具有 n 个缓冲区公用缓冲池</li><li>互斥信号量 mutex 实现诸进程对缓冲池的互斥使用</li><li>信号量 empty 表示缓冲池中空缓冲区数量。</li><li>信号量 full 表示缓冲池中满缓冲区的数量。</li><li>mutex 为公用信号量，full 与 empty 与私用信号量</li><li>缓冲池未满，生产者可以将消息送入缓冲池</li><li>缓冲池未空，消费者可以从缓冲池中取走消息</li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719737671_0.png" alt="image-20240630165431666" style="zoom:33%;"><ul><li>公有信号量：在单个程序成对出现</li><li>私有信号量：在不同程序中出现</li><li>先私后公</li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719737958_0.png" alt="image-20240630165918522" style="zoom:33%;"><p>​ 桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自已需要的水果时，儿子或女儿可以从盘子中取出水果。用 PV 操作实现上述过程。</p><p>同步关系：</p><ol><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲和母亲才能放入水果</li></ol><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719747647_0.png" alt="image-20240630194045601" style="zoom:33%;"><p>仓库管理有入货和出货两个操作。仓库内共有 50 个空位，最多存放 50 件货物。另外有一张登记表，无论入货或出货都需要在上面做登记。</p><ul><li>入货流程是：仓库登记，存放货物</li><li>出货流程是：仓库登记，取出货物</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Semaphore tmutex = 1, shelf = 50, item = 0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>In(){</span></span>
<span class="line"><span>	wait(shelf);	// 等待有空位</span></span>
<span class="line"><span>	wait(tmutex);</span></span>
<span class="line"><span>	登记;</span></span>
<span class="line"><span>	存放货物;</span></span>
<span class="line"><span>	signal(tmutex);</span></span>
<span class="line"><span>	signal(item);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Out(){</span></span>
<span class="line"><span>	wait(item);</span></span>
<span class="line"><span>	wait(tmutex);</span></span>
<span class="line"><span>	登记;</span></span>
<span class="line"><span>	取出货物;</span></span>
<span class="line"><span>	signal(tmutex);</span></span>
<span class="line"><span>	signal(shelf);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>​ 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719748343_0.png" alt="image-20240630195223254" style="zoom:33%;"><p>读者-写者问题</p><ul><li>一个数据文件可被多个进程共享</li><li>允许多个进程同时读，禁止多个进程同时写</li><li>当一个进程写的时候，其他所有读进程都要停止</li><li>当进程读的时候，不允许写进程的发生</li><li>读写是互斥的</li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719748889_0.png" alt="image-20240630200128707" style="zoom:33%;"><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719749058_0.png" alt="image-20240630200417891" style="zoom:33%;"><p>哲学家进餐问题：</p><ul><li>五个哲学家围坐一张圆桌</li><li>每两个哲学家之间有一根筷子</li><li>每个哲学家只能拿相邻的两根筷子，每次只能拿一根</li><li>每个哲学家只有拿到两根筷子才能进食</li></ul><hr><p>进程通信：</p><p>高级进程通信类型</p><ul><li>共享存储器，Share Memory，信息无格式</li><li>消息传递，Message Passing，信息有格式 <ul><li>直接通信：Send(P1, msg1), Receive(P1, msg1)</li><li>间接通信：信箱， Send(mailbox, message)， Receive(mailbox, message);</li></ul></li><li>管道通信，Pipe，以文件方式</li></ul><p>线程的特点：</p><ul><li>轻型实体。</li><li>独立调度和分派的基本单位。</li><li>可并发执行。</li><li>共享进程资源</li></ul><h2 id="第三章" tabindex="-1">第三章 <a class="header-anchor" href="#第三章" aria-label="Permalink to &quot;第三章&quot;">​</a></h2><p>处理机调度：</p><ul><li>高级调度：根据调度算法和计算机状态，从 <strong>外存中选择一个或多个作业调入内存</strong>，每个作业调入一次，调出一次，调入创建 PCB</li><li>低级调度：进程调度，决定哪个进程获得 CPU，保存现场，调度新进程， <ul><li>三个基本机制：排队器，分派器，上下文切换机制</li><li>非抢占式：正在运行的进程运行完毕或发生阻塞，才把 CPU 分配给其他进程</li><li>抢占式：允许暂停当前执行的进程，重新分配 CPU(优先权原则，短作业优先，时间片)</li></ul></li><li>中级调度：为了使得暂时不能运行的进程不占用宝贵的内存资源，将它们调至外存，挂起和唤醒，提高内存利用率和系统吞吐量</li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719756041_0.png" alt="image-20240630220041383" style="zoom:33%;"><p>高级、中级和低级调度：</p><ul><li>高级调度：以作业为调度对象 <ul><li>从外存到内存</li><li>进程创建操作</li></ul></li><li>中级调度：以进程为调度对象 <ul><li>外存与内存互换</li><li>挂起与唤醒操作</li></ul></li><li>低级调度：以进程为调度 <ul><li>对象一直在内存中</li><li>分配 CPU 执行程序</li></ul></li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719758768_0.png" alt="image-20240630224607972" style="zoom:50%;"><p>选择调度算法的准则：</p><ul><li>面向用户的准则：周转时间短(作业进入到完成的时间)，响应时间快，截止时间的保证，优先权准则</li><li>面向系统的准则：系统吞吐量高，处理机利用率好，各类资源的平衡利用</li></ul><p>固定属性：</p><ul><li>到达时间：进入系统的时间</li><li>开始时间：首次使用 CPU 的时间</li><li>服务时间：需要使用 CPU 的时间，又叫运行时间</li><li>完成时间：退出系统的时间</li><li><strong>周转时间：完成时间-到达时间</strong>，包含服务时间和等待时间，若等待时间为 0 即没有等待</li><li>平均周转时间：周转时间 / 服务时间</li><li><strong>带权周转时间 = 周转时间 / 运行时间</strong></li></ul><p>调度算法：</p><p>先来先服务调度 FCFS(非抢占式)：</p><ul><li>作业调度：按时间先后，选择最先来的作业</li><li>进程调度：从就绪队列中，选择最先进入的进程，队首进程</li></ul><p>短作业优先调度 SJF(非抢占式)：选择时间最短的，有利于短作业，导致长作业长时间不被调度，不能保证实时性</p><p>高优先权优先调度：</p><ul><li>静态优先：创建进程时已经确定并在运行时不变</li><li>动态优先：随进程的推进或等待时间增加而改变</li><li>优先权 = 等待时间+要求服务时间/要求服务时间 = 响应时间/要求服务时间</li></ul><p>高响应比优先调度算法的优点：</p><ul><li>对于等待时间相同的时候，服务时间愈短则优先权愈高，算法有利于短作业</li><li>对于服务时间相同的时候，等待时间愈长其优先权愈高，算法实现的是先来先服务。</li><li>对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高保证能获得处理机。</li></ul><p>缺点：每次调度前都要计算优先权，增加系统开销</p><p>基于时间片的轮转调度算法：</p><ul><li>将所有就绪进程按先来先服务排成队列</li><li>把 CPU 分配给队首进程，进程只执行一个时间片</li><li>时间片用完，OS 通过计时器发出时钟中断，停止进程</li><li>将已使用时间片的进程送往就绪队列的末尾</li><li>分配处理机给就绪队列中下一进程</li></ul><p>多级反馈队列调度算法调度规则：</p><ul><li>每个新进程首先进入第一个队列，遵循 FCFS</li><li>在当前队列的时间片内，进程若能完成，退出进程</li><li>若未完成，降级到第二个队列，同样遵循 FCFS</li><li>依次类推，若在第二个队列的时间片内仍未完成，再降级到第三个队列……</li><li>高级队列未空，低级队列不能调度</li></ul><p>实时调度：</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1719760872_0.png" alt="image-20240630232112016" style="zoom:50%;"><p>常用的几种实时调度算法</p><ul><li>最早截止时间优先(EDF, Earliest Deadline First)算法 <ul><li>根据任务的开始截止时间确定任务优先级</li><li>开始截止时间越早，优先级越高</li></ul></li><li>最低松弛度优先(LLF, Least Laxity First)算法 <ul><li>根据任务紧急(或松弛)的程度确定任务的优先级。</li><li>任务的紧急程度愈高，优先级就愈高</li><li>临界状态发生抢占，松弛度为 0 发生抢占</li><li><strong>松弛度 = 完成截止时间 – 处理时间 – 当前时间</strong></li><li>例如任务 A 的完成截止时间是第 400s，运行时间为 100s，当前时间是第 150s，则 A 的松弛度 = 400 – 100 – 150 = 150s</li><li>注意：处理时间指剩余需要 CPU 时间，初始化等于运行时间</li></ul></li></ul><p>死锁：多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前进产生</p><p>死锁的原因：竞争资源，进程间推进顺序非法</p><p>产生死锁的必要条件互斥条件：</p><ul><li>请求资源为临界资源，将引发进程阻塞</li><li>请求和保持条件：持有旧资源，同时申请新资源</li><li>不剥夺条件：已获得资源在使用完之前，不被外力剥夺</li><li>环路等待条件：互相等待资源</li></ul><p>处理死锁的基本方法</p><ul><li>预防死锁：设置限制条件，破坏产生死锁的一个或多个必要条件</li><li>避免死锁：在资源动态分配过程中，加入检查，防止系统进入不安全状态</li><li>检测死锁：建立检测机构检测死锁的发生和原因，确定相关的进程和资源</li><li>解除死锁：剥夺资源或撤销进程，从而解除死锁</li><li>检测死锁和解除死锁是一对合作关系</li></ul><h2 id="文件管理" tabindex="-1">文件管理 <a class="header-anchor" href="#文件管理" aria-label="Permalink to &quot;文件管理&quot;">​</a></h2><p>有结构文件：文件由若干个记录组成，例如表格</p><p>无结构文件：字符流，特例，只包含一个无标识记录的文件</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720000279_0.png" alt="image-20240703175119023" style="zoom:50%;"><p>文件属性：类型，长度，物理位置，建立时间</p><p>文件类型：</p><ul><li>系统文件，用户文件，库文件</li><li>数据形式：源文件，目标文件，可执行文件</li><li>存储形式：只执行，只读，可读/写</li></ul><p>文件系统：负责管理管理外存上的文件，为用户提供文件的存取、共享、保护等功能。</p><p>文件逻辑结构：即文件组织，用户可以直接处理的数据及其结构，分为有结构文件和无结构文件</p><p>文件物理结构：文件在外存上的存储组织形式</p><p>有结构文件：定长记录和变长记录，顺序文件，索引文件，索引顺序文件</p><p>UNIX 系统，所有文件都是流式文件</p><p>顺序文件：记录逻辑上一个一个顺序排列，记录可用定长/变长，记录在物理上可用顺序存储/链式存储</p><ul><li>串结构：记录之间的顺序与关键字无关</li><li>顺序结构：记录按关键词排序</li></ul><p>优点：适用于批量存取，连续大批读/写记录，磁带机</p><p>缺点：不方便查找与修改，含有 n 个记录，平均每次查找需要 n/2 次，可变长记录更大，增加新记录或删除旧记录麻烦，配置日志文件或事务文件</p><p>索引文件：</p><ul><li>为可变长记录文件建立一张索引表</li><li>索引表按关键字排序</li><li>索引表本身是定长记录的顺序文件</li><li>优点：方便增删改</li><li>缺点：索引表需要额外存储</li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720003699_0.png" alt="image-20240703184819066" style="zoom:50%;"><p>索引顺序文件：</p><ul><li>将记录分为若干组</li><li>每组的第一个记录作为索引项，建立索引表</li><li>索引表按记录键排序，是一个定长记录文件</li><li>索引表长度较短，节省存储空间</li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720003777_0.png" alt="image-20240703184937338" style="zoom:50%;"><p>三种文件的查找记录：100W 条记录</p><ul><li>顺序文件：50W 次</li><li>索引文件：按索引方法查找，额外 100W 个索引空间，50W 次</li><li>索引顺序文件：二级索引，100W -&gt; 10000 个组 -&gt; 100 个群，50 + 50 + 50 = 150 次</li></ul><p>文件目录：</p><p>文件控制块 FCB：</p><ul><li>基本信息类：文件名，物理位置，逻辑结构，物理结构</li><li>存取控制信息类</li><li>使用信息类</li></ul><p>单级目录：所有文件使用一张目录表</p><p>二级目录：按用户划分，提交速度，支持重名，方便共享</p><p>多级目录：构造目录树</p><ul><li>当前目录：为每个进程设置，简化路径</li><li>增减目录：建立新分支</li><li>删除目录：非空目录递归，从底向上删除</li><li>查询目录：树遍历，Hash 方法</li></ul><p>FCB 过大，单个盘的 FCB 数量较少，导致查找文件需要访问多个盘块，</p><p>索引节点，将文件描述信息存放在索引节点中，构建目录表，文件名和索引节点指针，</p><p>例如：FCB = 64B 盘块为 1KB，16 个 FCB，一个目录包含 640 个文件，需要 40 个盘块，查找需要 20 个盘块</p><p>目录项为 16 个字节，14B 用于文件名，2B 用于指针，1KB 存储 64 个目录项，只需访问 10 个盘块，平均查找 5 个盘块</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720004675_0.png" alt="image-20240703190435348" style="zoom:33%;"><p>磁盘索引结点：</p><ul><li>文件主标识符</li><li>类型、存取权限</li><li>物理地址、长度 连接计数</li><li>存取时间</li></ul><p>内存索引结点：将磁盘索引结点拷贝到内存</p><ul><li>内存索引结点编号</li><li>状态：结点是否上锁或被修改访问</li><li>计数：有新进程访问则计数加 1， 访问完再减 1</li><li>文件所属文件系统的逻辑设备号</li><li>链接指针：设置有分别指向空闲链表和散列队列的指针</li></ul><p>外存分配方式：</p><p>连续分配：为文件分配一组相邻接的盘块</p><p>优点：顺序访问/直接访问容易，访问速度快，</p><p>缺点：要求由连续的存储空间，产生碎片，存储时需要事先知道文件的长度，不方便文件拓展</p><p>文件目录记录：文件名 起始块号 长度</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720005274_0.png" alt="image-20240703191433894" style="zoom:50%;"><p>链接分配：将同一文件的盘块采用指针链接到一起</p><p>隐式链接：链接指针放在盘块内</p><p>优点：不存在碎片，不需要连续空间，不需要事先知道文件长度</p><p>缺点：</p><ul><li>适合顺序访问，不适合随机访问</li><li>可靠性差，指针出错会数据丢失</li><li>指针占用数据区</li></ul><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720005309_0.png" alt="image-20240703191508775" style="zoom:50%;"><p>显示链接：盘块的指针存放在链接表中，又称文件分配表，FAT 表，结尾-1</p><p>缺点：不支持高速直接存储；FAT 占用内存空间</p><p>优点：无外部碎片，方便拓展，转换不需要磁盘操作</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720005511_0.png" alt="image-20240703191830809" style="zoom:50%;"><p>索引分配：为每个文件分配索引表，将记录存在索引表，一级索引：每个文件只有一张索引表</p><p>缺点：额外空间，文件多会使得索引库过大，导致盘块更多，速度变慢 -&gt; 多级索引</p><p>计算最大文件长度：</p><p>一级索引：磁盘块 1KB，索引表项 4B，则一个磁盘块最多 256 个索引项，</p><p>一个文件 256*256KB = 64MB，由 256*256 个块，对应 256*256 个索引项，需要 256 个索引块，</p><p>二级索引：文件最大长度 256*256*1KB = 64MB</p><p>访问 1026 号逻辑块，1026/256 = 4，1026%256 = 2。一级索引 4 对应的二级索引，2 号表即为物理块，3 次磁盘 IO</p><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720005744_0.png" alt="image-20240703192224219" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Moriic/picture/main/image/1720006461_0.png" alt="image-20240703193421354" style="zoom:50%;"><p>在一操作系统中采用索引分配方式为文件分配外存，假定盘块大小为 4KB，每个盘块号占用 4 个字节，请分别计算使用一级索引、二级索引、三级索引支持的文件最大长度。</p><p>4KB/4B = 1024 = 2^10^ 个索引项</p><p>一级索引：2^10^ * 4KB = 2^12^ KB = 4MB</p><p>二级索引：2^10^ * 2^10^ * 4 KB = 2^22^ KB = 4GB</p><p>三级索引：2^10^ * 2^10^ * 2^10^ * 4 KB = 2^32^ KB = 4TB</p><p>文件存储空间的管理：对空间进行分配和回收</p><p>空闲表：</p>`,135)]))}const h=l(s,[["render",n]]);export{g as __pageData,h as default};
